T <- 2000
df <- 5
z.sim <- sim.garch(psi2arch(psi),T,rnorm(p),df)
plot(ts(z.sim))
lik.garch(psi,z.sim,p,df)
psi.init <- rep(0,p+q+2)
garch.fit <- optim(psi.init,fn=lik.tgarch,data=z.sim,p.order=p,method="BFGS")
print(garch.fit)
out <- cbind(c(psi2arch(garch.fit$par[1:(p+q+1)]),2+exp(arch.fit$par[p+q+2])),c(psi2arch(psi),df))
colnames(out) <- c("MLE","Truth")
label <- c("alpha0")
if(p > 0) { for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) } }
if(q > 0) { for(i in 1:q) { label <- c(label,paste("beta",i,sep="")) } }
label <- c(label,"df")
rownames(out) <- label
print(out)
garch.fit2 <- garch(z.sim, order = c(q, p))
lik.garch(arch2psi(garch.fit2$coef),z.sim,p,df=Inf)
out <- cbind(round(garch.fit2$coef,digits=6),psi2arch(psi))
colnames(out) <- c("MLE","Truth")
label <- c("alpha0")
if(p > 0) { for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) } }
if(q > 0) { for(i in 1:q) { label <- c(label,paste("beta",i,sep="")) } }
rownames(out) <- label
print(out)
lik.garch(arch2psi(coef(garch.fit3)[2:(p+q+2)]),z.sim,p,coef(garch.fit3)[p+q+3])
out <- cbind(round(coef(garch.fit3),digits=6),c(0,psi2arch(psi),df))
colnames(out) <- c("MLE","Truth")
label <- c("mu","alpha0")
if(p > 0) { for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) } }
if(q > 0) { for(i in 1:q) { label <- c(label,paste("beta",i,sep="")) } }
label <- c(label,"df")
rownames(out) <- label
print(out)
spec <- ugarchspec(variance.model=list(model="sGARCH", garchOrder=c(1,5)),
mean.model = list(armaOrder = c(0,0)),
distribution.model = "std")
garch.fit4 <- ugarchfit(data = z.sim, spec = spec)
lik.garch(arch2psi(coef(garch.fit4)[2:(p+q+2)]),z.sim,p,coef(garch.fit4)[p+q+3])
out <- cbind(round(coef(garch.fit4),digits=6),c(0,psi2arch(psi),df))
colnames(out) <- c("MLE","Truth")
label <- c("mu","alpha0")
if(p > 0) { for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) } }
if(q > 0) { for(i in 1:q) { label <- c(label,paste("beta",i,sep="")) } }
label <- c(label,"df")
rownames(out) <- label
print(out)
data(EuStockMarkets)
dax <- diff(log(EuStockMarkets))[,"DAX"]
dax.garch <- garch(dax)  # Fit a GARCH(1,1) to DAX returns
summary(dax.garch)       # ARCH effects are filtered. However,
plot(dax.garch)          # conditional normality seems to be violated
p <- 1
q <- 1
lik.garch(arch2psi(dax.garch$coef),dax,p,df=Inf)
out <- round(dax.garch$coef,digits=6)
out <- as.matrix(out)
colnames(out) <- c("MLE")
label <- c("alpha0")
if(p > 0) { for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) } }
if(q > 0) { for(i in 1:q) { label <- c(label,paste("beta",i,sep="")) } }
rownames(out) <- label
print(out)
psi.init <- c(arch2psi(dax.garch$coef),0)
garch.fit <- optim(psi.init,fn=lik.tgarch,data=dax,p.order=p,method="BFGS")
print(garch.fit)
out <- round(c(psi2arch(garch.fit$par[1:(p+q+1)]),2+exp(garch.fit$par[p+q+2])),digits=6)
out <- as.matrix(out)
colnames(out) <- c("MLE")
label <- c("alpha0")
if(p > 0) { for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) } }
if(q > 0) { for(i in 1:q) { label <- c(label,paste("beta",i,sep="")) } }
label <- c(label,"df")
rownames(out) <- label
print(out)
garch.fit3 <- garchFit(~ garch(1,1), data = dax, cond.dist = "std")
lik.garch(arch2psi(coef(garch.fit3)[2:(p+q+2)]),z.sim,p,coef(garch.fit3)[p+q+3])
out <- cbind(round(coef(garch.fit3),digits=6),c(0,psi2arch(psi),df))
colnames(out) <- c("MLE","Truth")
label <- c("mu","alpha0")
if(p > 0) { for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) } }
if(q > 0) { for(i in 1:q) { label <- c(label,paste("beta",i,sep="")) } }
label <- c(label,"df")
rownames(out) <- label
lik.garch(arch2psi(coef(garch.fit3)[2:(p+q+2)]),z.sim,p,coef(garch.fit3)[p+q+3])
out <- cbind(round(coef(garch.fit3),digits=6),c(0,psi2arch(psi),df))
out <- cbind(round(coef(garch.fit3),digits=6),NULL)
colnames(out) <- c("MLE")
label <- c("mu","alpha0")
if(p > 0) { for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) } }
if(q > 0) { for(i in 1:q) { label <- c(label,paste("beta",i,sep="")) } }
label <- c(label,"df")
rownames(out) <- label
print(out)
spec <- ugarchspec(variance.model=list(model="sGARCH", garchOrder=c(1,1)),
mean.model = list(armaOrder = c(0,0)),
distribution.model = "std")
garch.fit4 <- ugarchfit(data = z.sim, spec = spec)
spec <- ugarchspec(variance.model=list(model="sGARCH", garchOrder=c(1,1)),
mean.model = list(armaOrder = c(0,0)),
distribution.model = "std")
garch.fit4 <- ugarchfit(data = z.sim, spec = spec)
lik.garch(arch2psi(coef(garch.fit4)[2:(p+q+2)]),z.sim,p,coef(garch.fit4)[p+q+3])
out <- cbind(round(coef(garch.fit4),digits=6),NULL)
colnames(out) <- c("MLE")
label <- c("mu","alpha0")
if(p > 0) { for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) } }
if(q > 0) { for(i in 1:q) { label <- c(label,paste("beta",i,sep="")) } }
label <- c(label,"df")
rownames(out) <- label
print(out)
garch.fit3 <- garchFit(~ garch(1,1), data = dax, cond.dist = "std")
lik.garch(arch2psi(coef(garch.fit3)[2:(p+q+2)]),dax,p,coef(garch.fit3)[p+q+3])
out <- cbind(round(coef(garch.fit3),digits=6),NULL)
colnames(out) <- c("MLE")
label <- c("mu","alpha0")
if(p > 0) { for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) } }
if(q > 0) { for(i in 1:q) { label <- c(label,paste("beta",i,sep="")) } }
label <- c(label,"df")
rownames(out) <- label
print(out)
spec <- ugarchspec(variance.model=list(model="sGARCH", garchOrder=c(1,1)),
mean.model = list(armaOrder = c(0,0)),
distribution.model = "std")
garch.fit4 <- ugarchfit(data = z.sim, spec = spec)
spec <- ugarchspec(variance.model=list(model="sGARCH", garchOrder=c(1,1)),
mean.model = list(armaOrder = c(0,0)),
distribution.model = "std")
garch.fit4 <- ugarchfit(data = dax, spec = spec)
lik.garch(arch2psi(coef(garch.fit4)[2:(p+q+2)]),dax,p,coef(garch.fit4)[p+q+3])
out <- cbind(round(coef(garch.fit4),digits=6),NULL)
colnames(out) <- c("MLE")
label <- c("mu","alpha0")
if(p > 0) { for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) } }
if(q > 0) { for(i in 1:q) { label <- c(label,paste("beta",i,sep="")) } }
label <- c(label,"df")
rownames(out) <- label
print(out)
devtools::install_github("odeleongt/postr")
install.packages("devtools")
devtools::install_github("odeleongt/postr")
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
Sys.which("make")
devtools::install_github("odeleongt/postr")
webshot::install_phantomjs()
rmarkdown::draft("my_poster.Rmd", template = "poster", package = "postr")
install.packages("htmltools", type = "source")
install.packages("htmltools", type = "source")
rmarkdown::draft("my_poster.Rmd", template = "poster", package = "postr")
28927.73
28927.73 +105606.95
rm(list=ls())
library(xts)
# State-space models (will be replicated by MDFA)
library(dlm)
# Numerical package
library(numDeriv)
# Graphical package for recession-shading (empirical examples based on US-GDP)
library(tis)
#install.packages("devtools")
library(devtools)
# Load MDFA package from github
devtools::install_github("wiaidp/MDFA")
# MDFA package
library(MDFA)
library(mFilter)  # Classic filter designs (be replicated by MDFA)
library(RCurl)    # For getURL() and curl handler / cookie / google login
library(stringr)  # For str_trim() to trip whitespace from strings
library(Quandl)
require (Quandl)
#Quandl.api_key("ivVdJGV57TXA1RX5jgvp")
#  Tucker's libraries
library(expm)
library(R.utils)
library(xtable)
# set directory to GitHub/MDFA-Legacy
setwd("C:/Users/neide/OneDrive/Documents/GitHub/MDFA-Legacy")
path.main <- paste(getwd(),"/Sweave/",sep="")
path.pgm <- paste(path.main,"Rnw/",sep="")
path.out <- paste(path.main,"Latex/",sep="")
## Load MDFA R codes #
sourceDirectory(path=paste(path.main,"RcodeTSM/",sep=""), modifiedOnly=FALSE)
script <- paste(path.pgm,"MDFA_Legacy",sep="")
# Simulate a Gaussian VAR(1) of sample size 5000:
set.seed(1234)
burnin <- 10000
T.sim <- 5000
N <- 2
phi.matrix <- rbind(c(1/3,2/9),c(2,1/3))
out.svd <- svd(phi.matrix - diag(N))
alpha <- out.svd$u[,1,drop=FALSE] * sqrt(out.svd$d[1])
beta <- out.svd$v[,1,drop=FALSE] * sqrt(out.svd$d[1])
innovar.matrix <- diag(N)
x.init <- rep(0,N)
x.next <- x.init
x.sim <- NULL
for(t in 1:(T.sim+burnin))
{
x.next <- phi.matrix %*% x.next + t(chol(innovar.matrix)) %*% rnorm(N)
x.sim <- cbind(x.sim,x.next)
}
x.sim <- ts(t(x.sim[,-seq(1,burnin)]))
# construct and apply low pass filter
mu <- pi/6
len <- 1000
dpoly <- c(1,-1)
d <- length(dpoly) - 1
delta <- array(t(dpoly) %x% diag(N),c(N,N,d+1))
lp.filter <- c(mu/pi,sin(seq(1,len)*mu)/(pi*seq(1,len)))
lp.filter <- c(rev(lp.filter),lp.filter[-1])
x.lp.ideal <- mvar.filter(x.sim,array(t(lp.filter) %x% diag(N),c(N,N,(2*len+1))))
# get differenced data and partially differenced co-int aggregated data;
#  strip the latter's first observation to make sample size match grid
q <- 30
x.diff <- filter(x.sim,dpoly,method="convolution",sides=1)[(d+1):T.sim,]
x.all <- cbind(x.sim[-1,] %*% beta,x.diff)
grid <- T.sim - d
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# frf for ideal low-pass
frf.psi <- rep(0,grid)
frf.psi[abs(freq.ft) <= mu] <- 1
#frf.psi.sharp <- (frf.psi - frf.psi[m+1])/(exp(-1i*freq.ft)-1)
#frf.psi.sharp[m+1] <- 0
#frf.psi.sharp <- matrix(frf.psi.sharp,nrow=1) %x% diag(N)
#frf.psi.sharp <- array(frf.psi.sharp,c(N,N,grid))
frf.psi <- matrix(frf.psi,nrow=1) %x% diag(N)
frf.psi <- array(frf.psi,c(N,N,grid))
frf.deltan <- matrix(rep(1,grid),nrow=1) %x% diag(N)
frf.deltan <- array(frf.deltan,c(N,N,grid))
# for low pass frf get psi sharp, psi star, and coint vec;
#  modify psi sharp by coint constraint
rootfreqs <- 0
rem.vec <- mdfa.getremainder(frf.psi,rootfreqs)
frf.psi.sharp <- mdfa.getquotient(frf.psi,rootfreqs,rem.vec)
coint.vec <- mdfa.getremainder(frf.deltan,rootfreqs)
coint.coeff <- (diag(N) - coint.vec[1:N,,drop=FALSE]) %*% alpha %*% t(beta)
frf.coint <- array(rep(1,grid) %x% coint.coeff,c(N,N,grid))
frf.psi.flat <- frf.psi.sharp - frf.coint
dim(spec.hat[1,-1,])
dim(spec.hat.sharp[1,-1,])
# get mdfa filter and output
spec.hat.sharp <- mdfa.pergram(x.all,1)
dim(spec.hat.sharp[1,-1,])
dim(spec.hat.sharp[1,-1,,drop=FALSE])
mdfa.coint <- function(frf,spec.main,spec.coint,alpha,q)
{
#######################################################
#
#	mdfa.coint by Tucker McElroy
#
#	computes optimal concurrent moving average filter
#		as approx of given target filter, using MDFA method,
#		based upon the moving average filter class of length q
#	inputs:
#		frf is array N x N x Grid of complex entries, the target
#			frequency response function Psi(e^{-i lambda})
#			for lambda given by Grid number of Fourier frequencies
#		spec.main is array N x N x Grid of complex entries, the
#			process/data spectral density matrix f(lambda)
#		spec.coint is array r x N x Grid of complex entries, the
#			cross-spectral density matrix of Delta^N (L)Z_t with Delta (L)X_t
#   alpha: a N x r dimensional matrix, where r is number of
#     co-integrating relations
#   q: desired order of MA filter
#	outputs:
#		opt.array is array N x N x q of filter coefficients
#
##############################################################
N <- dim(spec.main)[1]
grid <- dim(frf)[3]
m <- floor(grid/2)
#	q <- dim(R)[2]
#	M <- dim(R)[4]
#	R.mat <- matrix(R,nrow=N*q,ncol=N*M)
#	Q.mat <- matrix(Q,ncol=N)
fpsi <- NULL
fmat <- NULL
lambda.ft <- exp(-1i*2*pi*grid^{-1}*(seq(1,grid) - (m+1)))	## this is e^{-i lambda}
#	opt.val <- do.call(cbind,lapply(seq(1,grid),function(i) frf[,,i] %*% spec.main[,,i] %*% Conj(t(frf[,,i]))))
#	opt.val <- grid^{-1}*opt.val %*% (rep(1,grid) %x% diag(N))
for(k in 0:(q-1))
{
fpsi.new <- do.call(cbind,lapply(seq(1,grid),
function(i) frf[,,i] %*% spec.main[,,i] + alpha %*% spec.coint[,,i]))
fpsi.new <- grid^{-1}*fpsi.new %*% (lambda.ft^{-k} %x% diag(N))
fpsi <- cbind(fpsi,fpsi.new)
fmat.new <- grid^{-1}*matrix(spec.main,nrow=N) %*% (lambda.ft^{-k} %x% diag(N))
if(k==0) {
fmat <- fmat.new
fzero <- fmat.new
} else {
if(k==1) {
fmat <- cbind(fmat,fmat.new)
fmat <- rbind(fmat,cbind(t(fmat.new),fzero))
} else {
side.mat <- fmat[1:(dim(fmat)[2]-N),(dim(fmat)[2]+1-N):dim(fmat)[2],drop=FALSE]
fmat <- cbind(fmat,rbind(fmat.new,side.mat))
fmat <- rbind(fmat,cbind(t(fmat.new),t(side.mat),fzero))
}
}
}
fpsi <- Re(fpsi)
fmat <- Re(fmat)
opt <- solve(fmat,t(fpsi))
opt.array <- array(t(opt),c(N,N,q))
return(opt.array)
}
lp.mdfa.sharp <- mdfa.coint(frf.psi.flat,spec.hat.sharp[-1,-1,],
spec.hat.sharp[1,-1,,drop=FALSE],alpha,q-d)
Q.mat <- rbind(rem.vec - coint.vec %*% alpha %*% t(beta), matrix(0,nrow=N*(q-d),ncol=N))
R.mat <- toeplitz(c(rev(dpoly),rep(0,q-d-1)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-seq(q-d+1,q)] %x% diag(N)
lp.mdfa.filter <- array(t(R.mat %*% t(matrix(lp.mdfa.sharp,nrow=N))
+ Q.mat),c(N,N,q))
x.lp.mdfa <- mvar.filter(x.sim,lp.mdfa.filter)[(len-q+2):(T.sim-q+1-len),]
# compare in-sample performance
print(c(mean((x.lp.ideal[,1] - x.lp.mdfa[,1])^2),
mean((x.lp.ideal[,2] - x.lp.mdfa[,2])^2)))
plot.ts(x.lp.ideal[,1])
lines(x.lp.mdfa[,1],col=2)
plot.ts(x.lp.ideal[,2])
lines(x.lp.mdfa[,2],col=2)
plot.ts(x.lp.mdfa)
beta
plot.ts(t(beta) %*% x.lp.mdfa)
plot.ts(x.lp.mdfa %*% beta)
alpha
plot.ts(x.lp.mdfa %*% alpha)
plot.ts(x.lp.mdfa)
x.lp.mda[1,]
x.lp.mdfa[1,]
plot.ts(x.lp.ideal)
plot.ts(x.lp.mdfa)
Q.mat
rem.vec
coint.vec
# Simulate a Gaussian LLM  of sample size 5000:
set.seed(1234)
T.sim <- 5000
burn <- 1000
N <- 2
psi.sim <- c(2.17150287559847, -8.36795922528, -6.04133725367594,
0.0648981656699, -6.80849700177184, -6.66004335288479,
-0.00016098322952, 0.00051984185863)
psi.sim[7:8] <- c(0,0)
len <- 1000
dpoly <- c(1,-1)
delta <- array(t(dpoly) %x% diag(N),c(N,N,2))
d <- length(dpoly) - 1
mu.sim <- mdfa.wnsim(psi.sim[1:3],rep(1,N),T.sim+burn,Inf)
Sigma.mu <- mu.sim[[2]]
mu.sim <- mdfa.ucsim(delta,mu.sim[[1]])[(burn+1-d):(T.sim+burn-d),]
irr.sim <- mdfa.wnsim(psi.sim[4:6],rep(1,N),T.sim,Inf)
Sigma.irr <- irr.sim[[2]]
irr.sim <- irr.sim[[1]]
x.sim <- mu.sim + irr.sim
# construct and apply MB WK and WH filters
grid <- T.sim - d
iden <- array(diag(N),c(N,N,1))
f.mu <- mdfa.spectra(iden,iden,Sigma.mu,grid)
f.irr <- mdfa.spectra(iden,iden,Sigma.irr,grid)
trend.wkfrf <- mdfa.wkfrf(iden,delta,f.irr,f.mu)
trend.wkfilter <- mdfa.coeff(trend.wkfrf,-len,len)
x.trend.ideal <- mvar.filter(x.sim,trend.wkfilter)
trend.whfrf <- mdfa.whfrf(iden,delta,f.irr,f.mu,len)
trend.whfilter <- mdfa.coeff(trend.whfrf,-len,len)
x.trend.conc <- mvar.filter(x.sim,trend.whfilter)
# get MDFA concurrent filter
q <- 30
x.diff <- filter(x.sim,dpoly,method="convolution",sides=1)[(d+1):T.sim,]
grid <- T.sim - d
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# for trend frf get psi sharp
rootfreqs <- 0
rem.vec <- mdfa.getremainder(trend.wkfrf,rootfreqs)
frf.psi.sharp <- mdfa.getquotient(trend.wkfrf,rootfreqs,rem.vec)
# get mdfa filter and output
spec.hat.sharp <- mdfa.pergram(x.diff,1)
trend.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-1)
R.mat <- toeplitz(c(-1,1,rep(0,q-2)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-q] %x% diag(N)
Q.mat <- rbind(rem.vec, matrix(0,nrow=N*(q-1),ncol=N))
#Q.mat <- c(1,rep(0,q-1)) %x% trend.wkfrf[,,m+1]
trend.mdfa.filter <- array(t(R.mat %*% t(matrix(trend.mdfa.sharp[[1]],nrow=N))
+ Q.mat),c(N,N,q))
x.trend.mdfa <- mvar.filter(x.sim,trend.mdfa.filter)[(len-q+2):(T.sim-q+1-len),]
# compare in-sample performance
perf_null <- cbind(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)),
c(mean((x.trend.ideal[,1] - x.trend.conc[,1])^2),
mean((x.trend.ideal[,2] - x.trend.conc[,2])^2)))
colnames(perf_null) <- c("MDFA","MB")
rownames(perf_null) <- c("Series 1","Series 2")
# compare to criterion value
print(perf_null)
diag(trend.mdfa.sharp[[2]])
# Simulate a Gaussian LLM  of sample size 5000:
set.seed(1234)
T.sim <- 5000
burn <- 1000
N <- 2
psi.sim <- c(2.17150287559847, -8.36795922528, -6.04133725367594,
0.0648981656699, -6.80849700177184, -6.66004335288479,
-0.00016098322952, 0.00051984185863)
psi.sim[5:6] <- c(-4,-4)
psi.sim[7:8] <- c(0,0)
len <- 1000
dpoly <- c(1,-1)
delta <- array(t(dpoly) %x% diag(N),c(N,N,2))
d <- length(dpoly) - 1
mu.sim <- mdfa.wnsim(psi.sim[1:3],rep(1,N),T.sim+burn,Inf)
Sigma.mu <- mu.sim[[2]]
mu.sim <- mdfa.ucsim(delta,mu.sim[[1]])[(burn+1-d):(T.sim+burn-d),]
irr.sim <- mdfa.wnsim(psi.sim[4:6],rep(1,N),T.sim,Inf)
Sigma.irr <- irr.sim[[2]]
irr.sim <- irr.sim[[1]]
x.sim <- mu.sim + irr.sim
# construct and apply MB WK and WH filters (from previous exercise)
x.trend.ideal <- mvar.filter(x.sim,trend.wkfilter)
x.trend.conc <- mvar.filter(x.sim,trend.whfilter)
# get MDFA concurrent filter
q <- 30
x.diff <- filter(x.sim,dpoly,method="convolution",sides=1)[(d+1):T.sim,]
grid <- T.sim - d
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# for trend frf get psi sharp
rootfreqs <- 0
rem.vec <- mdfa.getremainder(trend.wkfrf,rootfreqs)
frf.psi.sharp <- mdfa.getquotient(trend.wkfrf,rootfreqs,rem.vec)
# get mdfa filter and output
spec.hat.sharp <- mdfa.pergram(x.diff,1)
trend.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-1)
R.mat <- toeplitz(c(-1,1,rep(0,q-2)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-q] %x% diag(N)
#Q.mat <- c(1,rep(0,q-1)) %x% trend.wkfrf[,,m+1]
Q.mat <- rbind(rem.vec, matrix(0,nrow=N*(q-1),ncol=N))
trend.mdfa.filter <- array(t(R.mat %*% t(matrix(trend.mdfa.sharp[[1]],nrow=N))
+ Q.mat),c(N,N,q))
x.trend.mdfa <- mvar.filter(x.sim,trend.mdfa.filter)[(len-q+2):(T.sim-q+1-len),]
# compare in-sample performance
perf_alt <- cbind(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)),
c(mean((x.trend.ideal[,1] - x.trend.conc[,1])^2),
mean((x.trend.ideal[,2] - x.trend.conc[,2])^2)))
colnames(perf_alt) <- c("MDFA","MB")
rownames(perf_alt) <- c("Series 1","Series 2")
# compare to criterion value
print(perf_alt)
diag(trend.mdfa.sharp[[2]])
T <- dim(petrol)[1]
N <- dim(petrol)[2]
# truncation of ideal filter
trunc <- 5
# construct and apply MB WK and WH filters (from previous exercise)
x.trend.ideal <- mvar.filter(petrol,trend.wkfilter[,,(len-trunc*period):(len+trunc*period)])
x.trend.conc <- mvar.filter(petrol,trend.whfilter[,,(len-trunc*period):(len+trunc*period)])
# visualize
load("Sweave/Data/petrol.RData")
period <- 12
petrol <- ts(petrol[,c(1,2)],start=c(1973,1),frequency=period,
names=c("Consumption","Imports"))
T <- dim(petrol)[1]
N <- dim(petrol)[2]
# truncation of ideal filter
trunc <- 5
# construct and apply MB WK and WH filters (from previous exercise)
x.trend.ideal <- mvar.filter(petrol,trend.wkfilter[,,(len-trunc*period):(len+trunc*period)])
x.trend.conc <- mvar.filter(petrol,trend.whfilter[,,(len-trunc*period):(len+trunc*period)])
# get MDFA concurrent filter
q <- 30
x.diff <- filter(petrol,dpoly,method="convolution",sides=1)[(d+1):T,]
grid <- T - d
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# for trend frf get psi sharp
trend.wkfrf <- mdfa.frf(trend.wkfilter,len,grid)
rootfreqs <- 0
rem.vec <- mdfa.getremainder(trend.wkfrf,rootfreqs)
frf.psi.sharp <- mdfa.getquotient(trend.wkfrf,rootfreqs,rem.vec)
# get mdfa filter and output
spec.hat.sharp <- mdfa.pergram(x.diff,1)
trend.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-1)
R.mat <- toeplitz(c(-1,1,rep(0,q-2)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-q] %x% diag(N)
#Q.mat <- c(1,rep(0,q-1)) %x% trend.wkfrf[,,m+1]
Q.mat <- rbind(rem.vec, matrix(0,nrow=N*(q-1),ncol=N))
trend.mdfa.filter <- array(t(R.mat %*% t(matrix(trend.mdfa.sharp[[1]],nrow=N))
+ Q.mat),c(N,N,q))
x.trend.mdfa <- mvar.filter(petrol,trend.mdfa.filter)[(1+trunc*period-q):(T-q-trunc*period),]
# compare in-sample performance
perf_emp <- cbind(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)),
c(mean((x.trend.ideal[,1] - x.trend.conc[,1])^2),
mean((x.trend.ideal[,2] - x.trend.conc[,2])^2)))
colnames(perf_emp) <- c("MDFA","MB")
rownames(perf_emp) <- colnames(petrol)
# compare to criterion value
print(perf_emp)
diag(trend.mdfa.sharp[[2]])
help(var)
help(mean)
