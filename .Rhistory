# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# for trend frf get psi sharp
trend.wkfrf <- mdfa.frf(trend.wkfilter,len,grid)
rootfreqs <- c(0,0)
rem.vec <- mdfa.getremainder(trend.wkfrf,rootfreqs)
frf.psi.sharp <- mdfa.getquotient(trend.wkfrf,rootfreqs,rem.vec)
# get mdfa filter and output
spec.hat.sharp <- mdfa.pergram(x.diff,1)
trend.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-d)
R.mat <- toeplitz(c(rev(dpoly),rep(0,q-d-1)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-seq(q-d+1,q)] %x% diag(N)
#Q.mat <- c(1,rep(0,q-1)) %x% trend.wkfrf[,,m+1]
Q.mat <- rbind(rem.vec, matrix(0,nrow=N*(q-d),ncol=N))
trend.mdfa.filter <- array(t(R.mat %*% t(matrix(trend.mdfa.sharp[[1]],nrow=N))
+ Q.mat),c(N,N,q))
x.trend.mdfa <- mvar.filter(ndc,trend.mdfa.filter)[(1+trunc*period-q):(T-q-trunc*period),]
# compare in-sample performance
perf_emp <- cbind(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)),
c(mean((x.trend.ideal[,1] - x.trend.conc[,1])^2),
mean((x.trend.ideal[,2] - x.trend.conc[,2])^2)))
colnames(perf_emp) <- c("MDFA","MB")
rownames(perf_emp) <- colnames(ndc)
# compare to criterion value
print(perf_emp)
diag(trend.mdfa.sharp[[2]])
mdfa.unconstrained
# Simulate a Gaussian STM  of sample size 5000:
set.seed(777)
T.sim <- 5000
burn <- 1000
N <- 2
psi.sim <- c(1.8905590615422, -11.9288577633298, -12.0809347541079,
0.660897814610799, -8.2863379601304, -5.66645335346871,
-1.34743227511595e-05, -1.41207967213544e-05)
psi.sim[2:3] <- c(-8,-8)
psi.sim[7:8] <- c(0,0)
len <- 1000
dpoly <- c(1,-2,1)
delta <- array(t(dpoly) %x% diag(N),c(N,N,3))
d <- length(dpoly) - 1
mu.sim <- mdfa.wnsim(psi.sim[1:3],rep(1,N),T.sim+burn,Inf)
Sigma.mu <- mu.sim[[2]]
mu.sim <- mdfa.ucsim(delta,mu.sim[[1]])[(burn+1-d):(T.sim+burn-d),]
irr.sim <- mdfa.wnsim(psi.sim[4:6],rep(1,N),T.sim,Inf)
Sigma.irr <- irr.sim[[2]]
irr.sim <- irr.sim[[1]]
x.sim <- mu.sim + irr.sim
# construct and apply MB WK and WH filters (from previous exercise)
x.trend.ideal <- mvar.filter(x.sim,trend.wkfilter)
x.trend.conc <- mvar.filter(x.sim,trend.whfilter)
# get MDFA concurrent filter
q <- 30
x.diff <- filter(x.sim,dpoly,method="convolution",sides=1)[(d+1):T.sim,]
grid <- T.sim - d
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# for trend frf get psi sharp
rootfreqs <- c(0,0)
rem.vec <- mdfa.getremainder(trend.wkfrf,rootfreqs)
frf.psi.sharp <- mdfa.getquotient(trend.wkfrf,rootfreqs,rem.vec)
# get mdfa filter and output
spec.hat.sharp <- mdfa.pergram(x.diff,1)
trend.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-d)
R.mat <- toeplitz(c(rev(dpoly),rep(0,q-d-1)))
# truncation of ideal filter
trunc <- 8
T <- dim(ndc)[1]
N <- dim(ndc)[2]
# truncation of ideal filter
trunc <- 8
# construct and apply MB WK and WH filters (from previous exercise)
x.trend.ideal <- mvar.filter(ndc,trend.wkfilter[,,(len-trunc*period):(len+trunc*period)])
x.trend.conc <- mvar.filter(ndc,trend.whfilter[,,(len-trunc*period):(len+trunc*period)])
# get MDFA concurrent filter
q <- 30
x.diff <- filter(ndc,dpoly,method="convolution",sides=1)[(d+1):T,]
grid <- T - d
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# for trend frf get psi sharp
trend.wkfrf <- mdfa.frf(trend.wkfilter,len,grid)
rootfreqs <- c(0,0)
rem.vec <- mdfa.getremainder(trend.wkfrf,rootfreqs)
frf.psi.sharp <- mdfa.getquotient(trend.wkfrf,rootfreqs,rem.vec)
# get mdfa filter and output
spec.hat.sharp <- mdfa.pergram(x.diff,1)
trend.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-d)
R.mat <- toeplitz(c(rev(dpoly),rep(0,q-d-1)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-seq(q-d+1,q)] %x% diag(N)
#Q.mat <- c(1,rep(0,q-1)) %x% trend.wkfrf[,,m+1]
Q.mat <- rbind(rem.vec, matrix(0,nrow=N*(q-d),ncol=N))
trend.mdfa.filter <- array(t(R.mat %*% t(matrix(trend.mdfa.sharp[[1]],nrow=N))
+ Q.mat),c(N,N,q))
x.trend.mdfa <- mvar.filter(ndc,trend.mdfa.filter)[(1+trunc*period-q):(T-q-trunc*period),]
# compare in-sample performance
perf_emp <- cbind(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)),
c(mean((x.trend.ideal[,1] - x.trend.conc[,1])^2),
mean((x.trend.ideal[,2] - x.trend.conc[,2])^2)))
colnames(perf_emp) <- c("MDFA","MB")
rownames(perf_emp) <- colnames(ndc)
# compare to criterion value
print(perf_emp)
diag(trend.mdfa.sharp[[2]])
dim(spec.hat.sharp)
dim(frf.hat.sharp)
dim(frf.psi.sharp)
T
grid <- 2000
# for trend frf get psi sharp
trend.wkfrf <- mdfa.frf(trend.wkfilter,len,grid)
rootfreqs <- c(0,0)
rem.vec <- mdfa.getremainder(trend.wkfrf,rootfreqs)
frf.psi.sharp <- mdfa.getquotient(trend.wkfrf,rootfreqs,rem.vec)
dpoly
T <- dim(ndc)[1]
N <- dim(ndc)[2]
# truncation of ideal filter
trunc <- 3
# construct and apply MB WK and WH filters (from previous exercise)
x.trend.ideal <- mvar.filter(ndc,trend.wkfilter[,,(len-trunc*period):(len+trunc*period)])
x.trend.conc <- mvar.filter(ndc,trend.whfilter[,,(len-trunc*period):(len+trunc*period)])
# get MDFA concurrent filter
q <- 30
x.diff <- filter(ndc,dpoly,method="convolution",sides=1)[(d+1):T,]
grid <- T - d
T <- dim(ndc)[1]
N <- dim(ndc)[2]
# truncation of ideal filter
trunc <- 8
# construct and apply MB WK and WH filters (from previous exercise)
x.trend.ideal <- mvar.filter(ndc,trend.wkfilter[,,(len-trunc*period):(len+trunc*period)])
x.trend.conc <- mvar.filter(ndc,trend.whfilter[,,(len-trunc*period):(len+trunc*period)])
# truncation of ideal filter
trunc <- 3
# construct and apply MB WK and WH filters (from previous exercise)
x.trend.ideal <- mvar.filter(ndc,trend.wkfilter[,,(len-trunc*period):(len+trunc*period)])
x.trend.conc <- mvar.filter(ndc,trend.whfilter[,,(len-trunc*period):(len+trunc*period)])
# get MDFA concurrent filter
q <- 30
x.diff <- filter(ndc,dpoly,method="convolution",sides=1)[(d+1):T,]
grid <- T - d
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# for trend frf get psi sharp
trend.wkfrf <- mdfa.frf(trend.wkfilter,len,grid)
rootfreqs <- c(0,0)
rem.vec <- mdfa.getremainder(trend.wkfrf,rootfreqs)
frf.psi.sharp <- mdfa.getquotient(trend.wkfrf,rootfreqs,rem.vec)
# get mdfa filter and output
spec.hat.sharp <- mdfa.pergram(x.diff,1)
trend.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-d)
R.mat <- toeplitz(c(rev(dpoly),rep(0,q-d-1)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-seq(q-d+1,q)] %x% diag(N)
#Q.mat <- c(1,rep(0,q-1)) %x% trend.wkfrf[,,m+1]
Q.mat <- rbind(rem.vec, matrix(0,nrow=N*(q-d),ncol=N))
trend.mdfa.filter <- array(t(R.mat %*% t(matrix(trend.mdfa.sharp[[1]],nrow=N))
+ Q.mat),c(N,N,q))
x.trend.mdfa <- mvar.filter(ndc,trend.mdfa.filter)[(1+trunc*period-q):(T-q-trunc*period),]
# compare in-sample performance
perf_emp <- cbind(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)),
c(mean((x.trend.ideal[,1] - x.trend.conc[,1])^2),
mean((x.trend.ideal[,2] - x.trend.conc[,2])^2)))
colnames(perf_emp) <- c("MDFA","MB")
rownames(perf_emp) <- colnames(ndc)
# compare to criterion value
print(perf_emp)
diag(trend.mdfa.sharp[[2]])
dim(frf.psi.sharp)
plot.ts(frf.psi.sharp)[1,1,]
plot.ts(frf.psi.sharp[1,1,])
plot.ts(Re(frf.psi.sharp[1,1,]))
plot.ts(Re(frf.psi.sharp[1,2,]))
plot.ts(Re(frf.psi.sharp[2,1,]))
plot.ts(Re(frf.psi.sharp[2,2,]))
T <- dim(ndc)[1]
N <- dim(ndc)[2]
# truncation of ideal filter
trunc <- 1
# construct and apply MB WK and WH filters (from previous exercise)
x.trend.ideal <- mvar.filter(ndc,trend.wkfilter[,,(len-trunc*period):(len+trunc*period)])
x.trend.conc <- mvar.filter(ndc,trend.whfilter[,,(len-trunc*period):(len+trunc*period)])
# get MDFA concurrent filter
q <- 30
x.diff <- filter(ndc,dpoly,method="convolution",sides=1)[(d+1):T,]
grid <- T - d
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# for trend frf get psi sharp
trend.wkfrf <- mdfa.frf(trend.wkfilter,len,grid)
rootfreqs <- c(0,0)
rem.vec <- mdfa.getremainder(trend.wkfrf,rootfreqs)
frf.psi.sharp <- mdfa.getquotient(trend.wkfrf,rootfreqs,rem.vec)
# get mdfa filter and output
spec.hat.sharp <- mdfa.pergram(x.diff,1)
trend.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-d)
R.mat <- toeplitz(c(rev(dpoly),rep(0,q-d-1)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-seq(q-d+1,q)] %x% diag(N)
#Q.mat <- c(1,rep(0,q-1)) %x% trend.wkfrf[,,m+1]
Q.mat <- rbind(rem.vec, matrix(0,nrow=N*(q-d),ncol=N))
trend.mdfa.filter <- array(t(R.mat %*% t(matrix(trend.mdfa.sharp[[1]],nrow=N))
+ Q.mat),c(N,N,q))
x.trend.mdfa <- mvar.filter(ndc,trend.mdfa.filter)[(1+trunc*period-q):(T-q-trunc*period),]
# compare in-sample performance
perf_emp <- cbind(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)),
c(mean((x.trend.ideal[,1] - x.trend.conc[,1])^2),
mean((x.trend.ideal[,2] - x.trend.conc[,2])^2)))
T <- dim(ndc)[1]
N <- dim(ndc)[2]
# truncation of ideal filter
trunc <- 8
# construct and apply MB WK and WH filters (from previous exercise)
x.trend.ideal <- mvar.filter(ndc,trend.wkfilter[,,(len-trunc*period):(len+trunc*period)])
x.trend.conc <- mvar.filter(ndc,trend.whfilter[,,(len-trunc*period):(len+trunc*period)])
# get MDFA concurrent filter
q <- 30
x.diff <- filter(ndc,dpoly,method="convolution",sides=1)[(d+1):T,]
grid <- T - d
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# for trend frf get psi sharp
trend.wkfrf <- mdfa.frf(trend.wkfilter,len,grid)
rootfreqs <- c(0,0)
rem.vec <- mdfa.getremainder(trend.wkfrf,rootfreqs)
frf.psi.sharp <- mdfa.getquotient(trend.wkfrf,rootfreqs,rem.vec)
# get mdfa filter and output
spec.hat.sharp <- mdfa.pergram(x.diff,1)
trend.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-d)
R.mat <- toeplitz(c(rev(dpoly),rep(0,q-d-1)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-seq(q-d+1,q)] %x% diag(N)
#Q.mat <- c(1,rep(0,q-1)) %x% trend.wkfrf[,,m+1]
Q.mat <- rbind(rem.vec, matrix(0,nrow=N*(q-d),ncol=N))
trend.mdfa.filter <- array(t(R.mat %*% t(matrix(trend.mdfa.sharp[[1]],nrow=N))
+ Q.mat),c(N,N,q))
x.trend.mdfa <- mvar.filter(ndc,trend.mdfa.filter)[(1+trunc*period-q):(T-q-trunc*period),]
# compare in-sample performance
perf_emp <- cbind(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)),
c(mean((x.trend.ideal[,1] - x.trend.conc[,1])^2),
mean((x.trend.ideal[,2] - x.trend.conc[,2])^2)))
colnames(perf_emp) <- c("MDFA","MB")
rownames(perf_emp) <- colnames(ndc)
# compare to criterion value
print(perf_emp)
diag(trend.mdfa.sharp[[2]])
frf.psi.sharp[,,m+1]
m
frf.psi.sharp[,,m+2]
frf.psi.sharp[,,m]
frf.psi.sharp[,,m+1] <- 2*frf.psi.sharp[,,m] - frf.psi.sharp[,,m-1]
frf.psi.sharp[,,m+1]
plot.ts(Re(frf.psi.sharp[1,1,]))
# get mdfa filter and output
spec.hat.sharp <- mdfa.pergram(x.diff,1)
trend.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-d)
R.mat <- toeplitz(c(rev(dpoly),rep(0,q-d-1)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-seq(q-d+1,q)] %x% diag(N)
#Q.mat <- c(1,rep(0,q-1)) %x% trend.wkfrf[,,m+1]
Q.mat <- rbind(rem.vec, matrix(0,nrow=N*(q-d),ncol=N))
trend.mdfa.filter <- array(t(R.mat %*% t(matrix(trend.mdfa.sharp[[1]],nrow=N))
+ Q.mat),c(N,N,q))
x.trend.mdfa <- mvar.filter(ndc,trend.mdfa.filter)[(1+trunc*period-q):(T-q-trunc*period),]
# compare in-sample performance
perf_emp <- cbind(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)),
c(mean((x.trend.ideal[,1] - x.trend.conc[,1])^2),
mean((x.trend.ideal[,2] - x.trend.conc[,2])^2)))
colnames(perf_emp) <- c("MDFA","MB")
rownames(perf_emp) <- colnames(ndc)
# compare to criterion value
print(perf_emp)
diag(trend.mdfa.sharp[[2]])
frf <- frf.psi.sharp
spec <- spec.hat.sharp
N <- dim(frf)[1]
R.mat <- diag(q) %x% diag(N)
Q.mat <- matrix(0,nrow=N*q,ncol=N)
R <- array(R.mat,c(N,q,N,q))
Q <- array(Q.mat,c(N,q,N))
N <- dim(spec)[1]
grid <- dim(frf)[3]
m <- floor(grid/2)
q <- dim(R)[2]
M <- dim(R)[4]
R.mat <- matrix(R,nrow=N*q,ncol=N*M)
Q.mat <- matrix(Q,ncol=N)
fpsi <- NULL
fmat <- NULL
lambda.ft <- exp(-1i*2*pi*grid^{-1}*(seq(1,grid) - (m+1)))	## this is e^{-i lambda}
opt.val <- do.call(cbind,lapply(seq(1,grid),function(i) frf[,,i] %*% spec[,,i] %*% Conj(t(frf[,,i]))))
opt.val <- grid^{-1}*opt.val %*% (rep(1,grid) %x% diag(N))
opt.val
#	opt.val <- Re(opt.val) + t(t(fpsi) - fmat %*% Q.mat) %*%
#	  (solve(fmat) - R.mat %*% solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat)) %*%
#	  (t(fpsi) - fmat %*% Q.mat) - fpsi %*% solve(fmat) %*% t(fpsi)
opt.val <- Re(opt.val) + t(Q.mat) %*% fmat %*% Q.mat - t(Q.mat) %*% t(fpsi) - fpsi %*% Q.mat -
t(t(fpsi) - fmat %*% Q.mat) %*% R.mat %*% solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat) %*%
(t(fpsi) - fmat %*% Q.mat)
for(k in 0:(q-1))
{
fpsi.new <- do.call(cbind,lapply(seq(1,grid),function(i) frf[,,i] %*% spec[,,i]))
fpsi.new <- grid^{-1}*fpsi.new %*% (lambda.ft^{-k} %x% diag(N))
fpsi <- cbind(fpsi,fpsi.new)
fmat.new <- grid^{-1}*matrix(spec,nrow=N) %*% (lambda.ft^{-k} %x% diag(N))
if(k==0) {
fmat <- fmat.new
fzero <- fmat.new
} else {
if(k==1) {
fmat <- cbind(fmat,fmat.new)
fmat <- rbind(fmat,cbind(t(fmat.new),fzero))
} else {
side.mat <- fmat[1:(dim(fmat)[2]-N),(dim(fmat)[2]+1-N):dim(fmat)[2],drop=FALSE]
fmat <- cbind(fmat,rbind(fmat.new,side.mat))
fmat <- rbind(fmat,cbind(t(fmat.new),t(side.mat),fzero))
}
}
}
fpsi <- Re(fpsi)
fmat <- Re(fmat)
opt <- solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat) %*% (t(fpsi) - fmat %*% Q.mat)
opt <- R.mat %*% opt + Q.mat
#	opt.val <- Re(opt.val) + t(t(fpsi) - fmat %*% Q.mat) %*%
#	  (solve(fmat) - R.mat %*% solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat)) %*%
#	  (t(fpsi) - fmat %*% Q.mat) - fpsi %*% solve(fmat) %*% t(fpsi)
opt.val <- Re(opt.val) + t(Q.mat) %*% fmat %*% Q.mat - t(Q.mat) %*% t(fpsi) - fpsi %*% Q.mat -
t(t(fpsi) - fmat %*% Q.mat) %*% R.mat %*% solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat) %*%
(t(fpsi) - fmat %*% Q.mat)
opt.val
t(t(fpsi) - fmat %*% Q.mat) %*% R.mat %*% solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat) %*%
(t(fpsi) - fmat %*% Q.mat)
opt.val <- do.call(cbind,lapply(seq(1,grid),function(i) frf[,,i] %*% spec[,,i] %*% Conj(t(frf[,,i]))))
opt.val <- grid^{-1}*opt.val %*% (rep(1,grid) %x% diag(N))
opt.val
plot.ts(x.diff)
plot.ts(spec.hat.sharp[1,1,])
dim(spec.hat.sharp)
grid
plot(ndc)
head(ndc)
# rescale ndc
ndc <- ndc*10^{-3}
T <- dim(ndc)[1]
N <- dim(ndc)[2]
# truncation of ideal filter
trunc <- 8
# construct and apply MB WK and WH filters (from previous exercise)
x.trend.ideal <- mvar.filter(ndc,trend.wkfilter[,,(len-trunc*period):(len+trunc*period)])
x.trend.conc <- mvar.filter(ndc,trend.whfilter[,,(len-trunc*period):(len+trunc*period)])
# get MDFA concurrent filter
q <- 30
x.diff <- filter(ndc,dpoly,method="convolution",sides=1)[(d+1):T,]
grid <- T - d
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# for trend frf get psi sharp
trend.wkfrf <- mdfa.frf(trend.wkfilter,len,grid)
rootfreqs <- c(0,0)
rem.vec <- mdfa.getremainder(trend.wkfrf,rootfreqs)
frf.psi.sharp <- mdfa.getquotient(trend.wkfrf,rootfreqs,rem.vec)
# get mdfa filter and output
spec.hat.sharp <- mdfa.pergram(x.diff,1)
trend.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-d)
R.mat <- toeplitz(c(rev(dpoly),rep(0,q-d-1)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-seq(q-d+1,q)] %x% diag(N)
#Q.mat <- c(1,rep(0,q-1)) %x% trend.wkfrf[,,m+1]
Q.mat <- rbind(rem.vec, matrix(0,nrow=N*(q-d),ncol=N))
trend.mdfa.filter <- array(t(R.mat %*% t(matrix(trend.mdfa.sharp[[1]],nrow=N))
+ Q.mat),c(N,N,q))
x.trend.mdfa <- mvar.filter(ndc,trend.mdfa.filter)[(1+trunc*period-q):(T-q-trunc*period),]
# compare in-sample performance
perf_emp <- cbind(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)),
c(mean((x.trend.ideal[,1] - x.trend.conc[,1])^2),
mean((x.trend.ideal[,2] - x.trend.conc[,2])^2)))
colnames(perf_emp) <- c("MDFA","MB")
rownames(perf_emp) <- colnames(ndc)
# compare to criterion value
print(perf_emp)
diag(trend.mdfa.sharp[[2]])
path.data <- paste(path.main,"Data/",sep="")
load(paste(path.data,"ndc.Rdata",sep=""))
T <- dim(ndc)[1]
N <- dim(ndc)[2]
# truncation of ideal filter
trunc <- 8
# construct and apply MB WK and WH filters (from previous exercise)
x.trend.ideal <- mvar.filter(ndc,trend.wkfilter[,,(len-trunc*period):(len+trunc*period)])
head(ndc)
# visualize
load("Sweave/Data/petrol.RData")
period <- 12
petrol <- ts(petrol[,c(1,2)],start=c(1973,1),frequency=period,
names=c("Consumption","Imports"))
dim(petrol)
# visualize
load("Sweave/Data/ndc.RData")
period <- 12
ndc <- ts(ndc[-1,c(1,2)],start=c(1992,2),frequency=period,
names=c("Shipments","NewOrders"))
T <- dim(ndc)[1]
N <- dim(ndc)[2]
# truncation of ideal filter
trunc <- 8
head(ndc)
# construct and apply MB WK and WH filters (from previous exercise)
x.trend.ideal <- mvar.filter(ndc,trend.wkfilter[,,(len-trunc*period):(len+trunc*period)])
x.trend.conc <- mvar.filter(ndc,trend.whfilter[,,(len-trunc*period):(len+trunc*period)])
# get MDFA concurrent filter
q <- 30
x.diff <- filter(ndc,dpoly,method="convolution",sides=1)[(d+1):T,]
grid <- T - d
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# for trend frf get psi sharp
trend.wkfrf <- mdfa.frf(trend.wkfilter,len,grid)
rootfreqs <- c(0,0)
rem.vec <- mdfa.getremainder(trend.wkfrf,rootfreqs)
frf.psi.sharp <- mdfa.getquotient(trend.wkfrf,rootfreqs,rem.vec)
# get mdfa filter and output
spec.hat.sharp <- mdfa.pergram(x.diff,1)
trend.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-d)
R.mat <- toeplitz(c(rev(dpoly),rep(0,q-d-1)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-seq(q-d+1,q)] %x% diag(N)
#Q.mat <- c(1,rep(0,q-1)) %x% trend.wkfrf[,,m+1]
Q.mat <- rbind(rem.vec, matrix(0,nrow=N*(q-d),ncol=N))
trend.mdfa.filter <- array(t(R.mat %*% t(matrix(trend.mdfa.sharp[[1]],nrow=N))
+ Q.mat),c(N,N,q))
x.trend.mdfa <- mvar.filter(ndc,trend.mdfa.filter)[(1+trunc*period-q):(T-q-trunc*period),]
# compare in-sample performance
perf_emp <- cbind(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)),
c(mean((x.trend.ideal[,1] - x.trend.conc[,1])^2),
mean((x.trend.ideal[,2] - x.trend.conc[,2])^2)))
colnames(perf_emp) <- c("MDFA","MB")
rownames(perf_emp) <- colnames(ndc)
# compare to criterion value
print(perf_emp)
diag(trend.mdfa.sharp[[2]])
opt.val
opt.val <- do.call(cbind,lapply(seq(1,grid),function(i) frf[,,i] %*% spec[,,i] %*% Conj(t(frf[,,i]))))
opt.val <- grid^{-1}*opt.val %*% (rep(1,grid) %x% diag(N))
dim(fpsi)
fpsi[1,]
diag(trend.mdfa.sharp[[2]])
det(trend.mdfa.sharp[[2]])
log(det(trend.mdfa.sharp[[2]]))
perf_emp
temp <- x.trend.ideal - x.trend.mdfa
cov(temp)
cov(temp)*(147/148)
help(cov)
gg <- t(temp) %*% temp/148
gg
log(det(gg))
det(gg)
dim(fmat)
fmat[1:4,1:4]
# get MDFA concurrent filter
q <- 30
x.diff <- filter(ndc,dpoly,method="convolution",sides=1)[(d+1):T,]
dpoly
var(x.diff)
temp <- acf(x.diff,type="covariance",plot=FALSE)
temp$acf
temp$acf[1,,]
fmat[1:2,1:2]
temp$acf[2,,]
fmat[3:4,1:2]
fmat[1:2,3:4]
temp$acf[3,,]
fmat[1:2,5:6]
temp$acf[10,,]
fmat[1:2,19:20]
temp <- x.trend.ideal - x.trend.mdfa
dim(temp)
colMeans(temp)
var(temp)
colMeans(temp)/diag(sqrt(var(temp)))
plot.ts(temp[,1])
plot.ts(temp[,2])
dim(spec.hat.sharp)
m
spec.hat.sharp[,,m]
spec.hat.sharp[,,m+1]
lambda.fit[m+1]
lambda.ft[m+1]
lambda.ft[m]
plot.ts(spec.hat.sharp[1,1,])
plot.ts(spec.hat.sharp[1,1,])
m
plot.ts(spec.hat.sharp[1,1,150:180])
plot.ts(spec.hat.sharp[1,1,159:179])
