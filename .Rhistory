}
trispectral.Mean.Theory = function(f, g, breaks){
s = 0
lambda = 2*pi*seq(-floor(breaks/2), floor(breaks/2), 1)/breaks
for(i in 1:length(lambda)){
for(j in 1:length(lambda)){
for(k in 1:length(lambda)){
s = s + f(c(lambda[i], lambda[j], lambda[k]))*
g(c(lambda[i], lambda[j], lambda[k]))
}
}
}
s = s / (breaks^3)
return(Re(s))
}
tetraspectral.Mean.Theory = function(f, g, breaks){
s = 0
lambda = 2*pi*seq(-floor(breaks/2), floor(breaks/2), 1)/breaks
for(i in 1:length(lambda)){
for(j in 1:length(lambda)){
for(k in 1:length(lambda)){
for(l in 1:length(lambda)){
s = s + f(c(lambda[i], lambda[j], lambda[k], lambda[l]))*
g(c(lambda[i], lambda[j], lambda[k], lambda[l]))
}
}
}
}
s = s / (breaks^4)
return(Re(s))
}
bispectralAsympVariance = function(ps, bs, ts, qs, g, breaks){
#
# if(type == "separable"){
#   g1 = function(y){g(y[1])*g(y[2])}
#   g2 = function(y){g(y[1])*g(y[2])*g(y[3])}
#   y = 6*(3 * spectral.Mean.Theory(ps, g, breaks)*
#            trispectral.Mean.Theory(ts, g2, breaks)
#          + 3 * bispectral.Mean.Theory(bs, g1, breaks)^2 +
#            spectral.Mean.Theory(ps,g, breaks)^3)
# }else{
lambda = 2*pi*seq(-floor(breaks/2), floor(breaks/2), 1)/breaks
s1 = 0
s2 = 0
s3 = 0
for(i in 1:length(lambda)){
for(j in 1:length(lambda)){
s3 = s3 + g(c(lambda[i], lambda[j]))*
g(c(-lambda[i], -lambda[j]))*given_spectra(lambda[i])*
given_spectra(lambda[j])*given_spectra(-lambda[i] - lambda[j])
for(k in 1:length(lambda)){
s1 = s1 + g(c(lambda[i], lambda[j]))*
g(c(-lambda[i] - lambda[j], lambda[k]))*
given_bispectra(c(lambda[i], lambda[j]))*
given_bispectra(c(-lambda[i] - lambda[j], lambda[k]))
s2 = s2 + g(c(lambda[i], lambda[j]))*
g(c(-lambda[i] - lambda[j] - lambda[k], lambda[k]))*
given_trispectra(c(lambda[i], lambda[j], lambda[k]))*
given_spectra(-lambda[i] - lambda[j])
}
}
}
s1 = (s1/(breaks^3))*9*2
s2 = (s2/(breaks^3))*9*2
s3 = (s3/(breaks^2))*6
y = s1 + s2 + s3
# }
return(Re(y))
}
simul_z = function(n){
x = rnorm(n+2)
y = 0.1*x[1:n] + 0.2*x[2:(n+1)] + 0.3*x[3:(n+2)]
return(y)
}
psi = function(x){
0.1 + 0.2*x + 0.3*x^2
}
x <- rnorm(100)
polyspectra.Estimate(x,0)
discrete.Fourier(x,0)
sum(x)
lambda <- 0
ll = length(lambda)
pl = 1
for(i in 1:ll){
pl = pl*discrete.Fourier(x, lambda[i])
}
pl = pl*discrete.Fourier(x, - sum(lambda))
#pl = pl/length(x)
pl = pl*((2*pi)^(-ll))/length(x)
pl
ll = length(lambda)
pl = 1
for(i in 1:ll){
pl = pl*discrete.Fourier(x, lambda[i])
}
pl = pl*discrete.Fourier(x, - sum(lambda))
pl
((2*pi)^(-ll))
-ll
(2*pi)^(-ll)
(2*pi)^3
pi
pi
set.seed(112358)
library(TSA)
pi
library(multitaper)
pi
library(rhosa)
pi
discrete.Fourier = function(x, lambda){
s = 0
for(i in 0:(length(x)-1)){
z = complex(1, cos(lambda*i), -sin(lambda*i))
s = s + x[i+1]*z
}
return(s)
}
pi
polyspectra.Estimate = function(x, lambda){
ll = length(lambda)
pl = 1
for(i in 1:ll){
pl = pl*discrete.Fourier(x, lambda[i])
}
pl = pl*discrete.Fourier(x, - sum(lambda))
#pl = pl/length(x)
pl = pl*((2*pi)^(-ll))/length(x)
return(pl)
}
pi
x <- rnorm(100)
polyspectra.Estimate(x,0)
mean(x)
mean(x)^2
sum(x)^2/100
spectral.Mean.Estimate = function(x, g){
lambda = 2*pi*seq(-floor(length(x)/2), floor(length(x)/2), 1)/length(x)
s = 0
for(i in 1:length(lambda)){
s = s + polyspectra.Estimate(x, lambda[i])*g(lambda[i])
}
s = s / (length(x))
return(Re(s))
}
pi
bispectral.Mean.Estimate = function(x, g){
lambda = 2*pi*seq(-floor(length(x)/2), floor(length(x)/2), 1)/length(x)
s = 0
sc = NULL
for(i in 1:length(lambda)){
for(j in 1:length(lambda)){
f = polyspectra.Estimate(x, c(lambda[i], lambda[j]))*
g(c(lambda[i], lambda[j]))
s = s + f
sc = c(sc, f)
}
}
s = s / (length(x)^2)
return(Re(s))
}
pi
spectral.Mean.Theory = function(f, g, breaks){
lambda = 2*pi*seq(-floor(breaks/2), floor(breaks/2), 1)/breaks
s = 0
for(i in 1:length(lambda)){
s = s + f(lambda[i])*g(lambda[i])
}
s = s / (breaks)
return(Re(s))
}
pi
trispectral.Mean.Theory = function(f, g, breaks){
s = 0
lambda = 2*pi*seq(-floor(breaks/2), floor(breaks/2), 1)/breaks
for(i in 1:length(lambda)){
for(j in 1:length(lambda)){
for(k in 1:length(lambda)){
s = s + f(c(lambda[i], lambda[j], lambda[k]))*
g(c(lambda[i], lambda[j], lambda[k]))
}
}
}
s = s / (breaks^3)
return(Re(s))
}
pi
tetraspectral.Mean.Theory = function(f, g, breaks){
s = 0
lambda = 2*pi*seq(-floor(breaks/2), floor(breaks/2), 1)/breaks
for(i in 1:length(lambda)){
for(j in 1:length(lambda)){
for(k in 1:length(lambda)){
for(l in 1:length(lambda)){
s = s + f(c(lambda[i], lambda[j], lambda[k], lambda[l]))*
g(c(lambda[i], lambda[j], lambda[k], lambda[l]))
}
}
}
}
s = s / (breaks^4)
return(Re(s))
}
pi
bispectralAsympVariance = function(ps, bs, ts, qs, g, breaks){
#
# if(type == "separable"){
#   g1 = function(y){g(y[1])*g(y[2])}
#   g2 = function(y){g(y[1])*g(y[2])*g(y[3])}
#   y = 6*(3 * spectral.Mean.Theory(ps, g, breaks)*
#            trispectral.Mean.Theory(ts, g2, breaks)
#          + 3 * bispectral.Mean.Theory(bs, g1, breaks)^2 +
#            spectral.Mean.Theory(ps,g, breaks)^3)
# }else{
lambda = 2*pi*seq(-floor(breaks/2), floor(breaks/2), 1)/breaks
s1 = 0
s2 = 0
s3 = 0
for(i in 1:length(lambda)){
for(j in 1:length(lambda)){
s3 = s3 + g(c(lambda[i], lambda[j]))*
g(c(-lambda[i], -lambda[j]))*given_spectra(lambda[i])*
given_spectra(lambda[j])*given_spectra(-lambda[i] - lambda[j])
for(k in 1:length(lambda)){
s1 = s1 + g(c(lambda[i], lambda[j]))*
g(c(-lambda[i] - lambda[j], lambda[k]))*
given_bispectra(c(lambda[i], lambda[j]))*
given_bispectra(c(-lambda[i] - lambda[j], lambda[k]))
s2 = s2 + g(c(lambda[i], lambda[j]))*
g(c(-lambda[i] - lambda[j] - lambda[k], lambda[k]))*
given_trispectra(c(lambda[i], lambda[j], lambda[k]))*
given_spectra(-lambda[i] - lambda[j])
}
}
}
s1 = (s1/(breaks^3))*9*2
s2 = (s2/(breaks^3))*9*2
s3 = (s3/(breaks^2))*6
y = s1 + s2 + s3
# }
return(Re(y))
}
pi
simul_z = function(n){
x = rnorm(n+2)
y = 0.1*x[1:n] + 0.2*x[2:(n+1)] + 0.3*x[3:(n+2)]
return(y)
}
pi
psi = function(x){
0.1 + 0.2*x + 0.3*x^2
}
pi
given_spectra = function(lambda){
z = complex(1, cos(lambda) , - sin(lambda))
z = psi(z)
y = z*Conj(z)
return(y)
}
pi
discrete.Fourier(x,0)
polyspectra.Estimate(x,0)
temp <- Re(discrete.Fourier(x,0))
temp^2/100
temp^2/(2*pi*100)
help(spec)
out <- spectrum(x,method="pgram")
names(out)
out$spec
out$freq
polyspectra.Estimate(x,out$freq[1]*2*pi)
out <- spectrum(x,method="pgram",demean=FALSE)
out$spec[1]
discrete.Fourier = function(x, lambda){
s = 0
for(i in 1:length(x)){
z = complex(1, cos(lambda*i), -sin(lambda*i))
s = s + x[i]*z
}
return(s)
}
polyspectra.Estimate(x,out$freq[1]*2*pi)
polyspectra.Estimate = function(x, lambda){
ll = length(lambda)
pl = 1
for(i in 1:ll){
pl = pl*discrete.Fourier(x, lambda[i])
}
pl = pl*discrete.Fourier(x, - sum(lambda))
#pl = pl/length(x)
pl = pl*((2*pi)^(-ll))/length(x)
return(pl)
}
polyspectra.Estimate(x,out$freq[1]*2*pi)
polyspectra.Estimate(x,out$freq[2]*2*pi)
polyspectra.Estimate(x,out$freq[3]*2*pi)
out$spec[1]
out$spec[2]
out$spec[3]
polyspectra.Estimate(x,out$freq[50]*2*pi)
out$spec[50]
sum(x*(-1)^seq(1,n))
n <- 100
sum(x*(-1)^seq(1,n))
sum(x*(-1)^seq(1,n))^2/n
sum(x*(-1)^seq(1,n))^2/(2*pi*n)
out <- spectrum(x,method="pgram")
out$freq[50]
spec$freq[50]
out$spec[50]
help(spectrum)
plot.ts(out$spec)
for(i in 1:50) { temp[i] <- polyspectra.Estimate(x,out$freq[i]*2*pi) }
for(i in 1:50) { temp[i] <- Re(polyspectra.Estimate(x,out$freq[i]*2*pi)) }
lines(temp,col=2)
temp
temp <- Re(temp)
temp
lines(temp,col=2)
out$spec/temp
log(out$spec)/temp
help(spectrum)
out$spec
sum(x*(-1)^seq(1,n))
sum(x*(-1)^seq(1,n))^2/n
spec.pgram
spec.pgram(x,detrend=FALSE)
out <- spec.pgram(x,detrend=FALSE)
names(out)
out$spec
out$n.used
out$detrend
out$demean
out$freq[25]
out$freq[25]*2*pi
out$freq[25]*2
sum(x*exp(-1i*seq(1,n)*pi))^2/n
sum(x*exp(-1i*seq(1,n)*pi/2))^2/n
Mod(sum(x*exp(-1i*seq(1,n)*pi/2)))^2/n
out$spec[25]
out$spec[25]/Mod(sum(x*exp(-1i*seq(1,n)*pi/2)))^2/n
Mod(sum(x*exp(-1i*seq(1,n)*pi/2)))^2/n
out$spec[25]
(Mod(sum(x*exp(-1i*seq(1,n)*pi/2)))^2/n)/out$spec[25]
(Mod(sum(x*exp(-1i*seq(1,n)*pi)))^2/n)/out$spec[50]
(Mod(sum(x*exp(-1i*seq(0,n-1)*pi)))^2/n)/out$spec[50]
polysectra.Estimate(x,out$freq[25]*2*pi)
polyspectra.Estimate(x,out$freq[25]*2*pi)
Mod(sum(x*exp(-1i*seq(1,n)*pi/2)))^2/(2*pi*n)
get.qmat <- function(mesh)
{
mesh2 <- floor(mesh/2)
inds <- seq(mesh2-mesh+1,mesh2)
Q.mat <- exp(1i*2*pi*mesh^{-1}*t(t(seq(1,mesh)) %x% inds))*mesh^{-1/2}
return(Q.mat)
}
## check: even case
Q.mat <- get.qmat(4)
x.sim <- rnorm(4)
x.dft <- Conj(t(Q.mat)) %*% x.sim
x.dft
## note: fft in base R does not yield the same result,
#	as it is based on a different formula than what we use in the book
fft(x.sim)/sqrt(4)
## check: odd case
Q.mat <- get.qmat(5)
x.sim <- rnorm(5)
x.dft <- Conj(t(Q.mat)) %*% x.sim
x.dft
fft(x.sim)/sqrt(5)
help(fft)
ttt <- fft(x)
Mod(ttt)^2/n
Mod(ttt)^2/(2*pi*n)
Mod(ttt)^2/(n)
sum(x)^2/n
Mod(ttt[1:50])^2/(n)
out$spec
out$spec/(2*pi)
Mod(ttt[2:51])^2/(n)
out$spec
(Mod(ttt[2:51])^2/(n))/out$spec
help(spectrum)
out <- spectrum(x,fast=FALSE,demean=FALSE)
out$spec
polyspectra.Estimate(x,out$freq[1]*2*pi)
polyspectra.Estimate(x,out$freq[50]*2*pi)
polyspectra.Estimate(x,out$freq[50]*2*pi)*2*pi
for(i in 1:50) { temp[i] <- polyspectra.Estimate(x,out$freq[i]*2*pi)*2*pi }
temp
Mod(ttt[2:51])^2/(n)
set.seed(112358)
library(TSA)
library(multitaper)
library(rhosa)
discrete.Fourier = function(x, lambda){
s = 0
for(i in 0:(length(x)-1)){
z = complex(1, cos(lambda*i), -sin(lambda*i))
s = s + x[i+1]*z
}
return(s)
}
polyspectra.Estimate = function(x, lambda){
ll = length(lambda)
pl = 1
for(i in 1:ll){
pl = pl*discrete.Fourier(x, lambda[i])
}
pl = pl*discrete.Fourier(x, - sum(lambda))
#pl = pl/length(x)
pl = pl*((2*pi)^(-ll))/length(x)
return(pl)
}
n <- 100
x <- rnorm(100)
x.pgram <- spectrum(x,demean=FALSE)
x.pgram$spec
sum(x*(-1)^seq(1,n))^2/n
x.pgram$spec[50]
x.dft <- fft(x)
Mod(x.dft)^2/n
x.dft <- fft(x)
Mod(x.dft[50:1])^2/n
x.dj <- rep(0,50)
for(i in 1:50) { x.dj[i] <- polyspectra.Estimate(x,x.pgram$freq[i]*2*pi)*2*pi }
x.dj <- rep(0,50)
for(i in 1:50) { x.dj[i] <- polyspectra.Estimate(x,x.pgram$freq[i]*2*pi)*2*pi }
x.dj
x.dft <- fft(x)
Mod(x.dft[1:50])^2/n
x.dft <- fft(x)
Mod(x.dft[51:100])^2/n
x.dft <- fft(x)
Mod(x.dft[1:50])^2/n
x.dft <- fft(x)
Mod(x.dft[2:51])^2/n
x.pgram <- spectrum(x,demean=FALSE,detrend=FALSE,fast=FALSE)
x.pgram$spec
x.pgram$spec/x.dj
x.pgram <- spec.pgram(x,demean=FALSE,detrend=FALSE,fast=FALSE)
x.pgram$spec
x.pgram <- spec.pgram(x,demean=FALSE,detrend=FALSE,fast=FALSE,spans=NULL)
x.pgram$spec
x.pgram <- spectrum(x,demean=FALSE,plot=FALSE)
x.pgram$spec
x.pgram <- spec.pgram(x,demean=FALSE,detrend=FALSE,fast=FALSE,spans=NULL,plot=FALSE)
x.pgram$spec
x.pgram$freq
names(x.pgram)
x.pgram$taper
x.pgram$method
x.pgram$kernel
x.pgram <- spec.pgram(x,demean=FALSE,detrend=FALSE,fast=FALSE,spans=NULL,
plot=FALSE,taper=1)
x.pgram <- spec.pgram(x,demean=FALSE,detrend=FALSE,fast=FALSE,spans=NULL,
plot=FALSE,taper=.5)
x.pgram$spec
x.pgram$spec/x.dj
x.pgram <- spec.pgram(x,demean=FALSE,detrend=FALSE,fast=FALSE,spans=NULL,
plot=FALSE,taper=0)
x.pgram$spec
x.pgram <- spec.pgram(x,demean=FALSE,detrend=FALSE,fast=FALSE,
plot=FALSE,taper=0)
x.pgram$spec
rm(list=ls())
library(xts)
# State-space models (will be replicated by MDFA)
library(dlm)
# Numerical package
library(numDeriv)
# Graphical package for recession-shading (empirical examples based on US-GDP)
library(tis)
#install.packages("devtools")
library(devtools)
# Load MDFA package from github
devtools::install_github("wiaidp/MDFA")
# MDFA package
library(MDFA)
library(RCurl)    # For getURL() and curl handler / cookie / google login
library(stringr)  # For str_trim() to trip whitespace from strings
library(Quandl)
require (Quandl)
#Quandl.api_key("ivVdJGV57TXA1RX5jgvp")
#  Tucker's libraries
library(expm)
library(R.utils)
library(xtable)
# set directory to GitHub/MDFA-Legacy
setwd("C:/Users/neide/Documents/GitHub/MDFA-Legacy")
path.main <- paste(getwd(),"/Sweave/",sep="")
path.pgm <- paste(path.main,"Rnw/",sep="")
path.out <- paste(path.main,"Latex/",sep="")
## Load MDFA R codes #
sourceDirectory(path=paste(path.main,"RcodeTSM/",sep=""), modifiedOnly=FALSE)
script <- paste(path.pgm,"MDFA_Legacy",sep="")
## enforce par(ask=FALSE)
options(device.ask.default=FALSE)
## create a LaTeX file
Sweave(script,output=paste(path.out,"MDFA_Legacy.tex",sep=""))
## create a LaTeX file
Sweave(script,output=paste(path.out,"MDFA_Legacy.tex",sep=""))
## create a LaTeX file
Sweave(script,output=paste(path.out,"MDFA_Legacy.tex",sep=""))
## create a LaTeX file
Sweave(script,output=paste(path.out,"MDFA_Legacy.tex",sep=""))
## create a LaTeX file
Sweave(script,output=paste(path.out,"MDFA_Legacy.tex",sep=""))
amat <- matrix(c(1/3,2/9,2,1/3),c(2,2))
amat
eigen(t(amat))
