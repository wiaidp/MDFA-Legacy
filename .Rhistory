lik.garch(arch2psi(coef(garch.fit3)[2:(p+q+2)]),z.sim,p,coef(garch.fit3)[p+q+3])
out <- cbind(round(coef(garch.fit3),digits=6),c(0,psi2arch(psi),df))
colnames(out) <- c("MLE","Truth")
label <- c("mu","alpha0")
if(p > 0) { for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) } }
if(q > 0) { for(i in 1:q) { label <- c(label,paste("beta",i,sep="")) } }
label <- c(label,"df")
rownames(out) <- label
lik.garch(arch2psi(coef(garch.fit3)[2:(p+q+2)]),z.sim,p,coef(garch.fit3)[p+q+3])
out <- cbind(round(coef(garch.fit3),digits=6),c(0,psi2arch(psi),df))
out <- cbind(round(coef(garch.fit3),digits=6),NULL)
colnames(out) <- c("MLE")
label <- c("mu","alpha0")
if(p > 0) { for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) } }
if(q > 0) { for(i in 1:q) { label <- c(label,paste("beta",i,sep="")) } }
label <- c(label,"df")
rownames(out) <- label
print(out)
spec <- ugarchspec(variance.model=list(model="sGARCH", garchOrder=c(1,1)),
mean.model = list(armaOrder = c(0,0)),
distribution.model = "std")
garch.fit4 <- ugarchfit(data = z.sim, spec = spec)
spec <- ugarchspec(variance.model=list(model="sGARCH", garchOrder=c(1,1)),
mean.model = list(armaOrder = c(0,0)),
distribution.model = "std")
garch.fit4 <- ugarchfit(data = z.sim, spec = spec)
lik.garch(arch2psi(coef(garch.fit4)[2:(p+q+2)]),z.sim,p,coef(garch.fit4)[p+q+3])
out <- cbind(round(coef(garch.fit4),digits=6),NULL)
colnames(out) <- c("MLE")
label <- c("mu","alpha0")
if(p > 0) { for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) } }
if(q > 0) { for(i in 1:q) { label <- c(label,paste("beta",i,sep="")) } }
label <- c(label,"df")
rownames(out) <- label
print(out)
garch.fit3 <- garchFit(~ garch(1,1), data = dax, cond.dist = "std")
lik.garch(arch2psi(coef(garch.fit3)[2:(p+q+2)]),dax,p,coef(garch.fit3)[p+q+3])
out <- cbind(round(coef(garch.fit3),digits=6),NULL)
colnames(out) <- c("MLE")
label <- c("mu","alpha0")
if(p > 0) { for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) } }
if(q > 0) { for(i in 1:q) { label <- c(label,paste("beta",i,sep="")) } }
label <- c(label,"df")
rownames(out) <- label
print(out)
spec <- ugarchspec(variance.model=list(model="sGARCH", garchOrder=c(1,1)),
mean.model = list(armaOrder = c(0,0)),
distribution.model = "std")
garch.fit4 <- ugarchfit(data = z.sim, spec = spec)
spec <- ugarchspec(variance.model=list(model="sGARCH", garchOrder=c(1,1)),
mean.model = list(armaOrder = c(0,0)),
distribution.model = "std")
garch.fit4 <- ugarchfit(data = dax, spec = spec)
lik.garch(arch2psi(coef(garch.fit4)[2:(p+q+2)]),dax,p,coef(garch.fit4)[p+q+3])
out <- cbind(round(coef(garch.fit4),digits=6),NULL)
colnames(out) <- c("MLE")
label <- c("mu","alpha0")
if(p > 0) { for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) } }
if(q > 0) { for(i in 1:q) { label <- c(label,paste("beta",i,sep="")) } }
label <- c(label,"df")
rownames(out) <- label
print(out)
devtools::install_github("odeleongt/postr")
install.packages("devtools")
devtools::install_github("odeleongt/postr")
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
Sys.which("make")
devtools::install_github("odeleongt/postr")
webshot::install_phantomjs()
rmarkdown::draft("my_poster.Rmd", template = "poster", package = "postr")
install.packages("htmltools", type = "source")
install.packages("htmltools", type = "source")
rmarkdown::draft("my_poster.Rmd", template = "poster", package = "postr")
rm(list=ls())
library(xts)
# State-space models (will be replicated by MDFA)
library(dlm)
# Numerical package
library(numDeriv)
# Graphical package for recession-shading (empirical examples based on US-GDP)
library(tis)
#install.packages("devtools")
library(devtools)
# Load MDFA package from github
devtools::install_github("wiaidp/MDFA")
# MDFA package
library(MDFA)
library(RCurl)    # For getURL() and curl handler / cookie / google login
library(stringr)  # For str_trim() to trip whitespace from strings
library(Quandl)
require (Quandl)
#Quandl.api_key("ivVdJGV57TXA1RX5jgvp")
#  Tucker's libraries
library(expm)
library(R.utils)
library(xtable)
# set directory to GitHub/MDFA-Legacy
setwd("C:/Users/neide/Documents/GitHub/MDFA-Legacy")
path.main <- paste(getwd(),"/Sweave/",sep="")
path.pgm <- paste(path.main,"Rnw/",sep="")
path.out <- paste(path.main,"Latex/",sep="")
## Load MDFA R codes #
sourceDirectory(path=paste(path.main,"RcodeTSM/",sep=""), modifiedOnly=FALSE)
script <- paste(path.pgm,"MDFA_Legacy",sep="")
## enforce par(ask=FALSE)
options(device.ask.default=FALSE)
# Simulate a VAR(1) of sample size 5000:
set.seed(1234)
T <- 5000
N <- 2
levels <- c(1,2)
slopes <- c(-2,1)/1000
phi.matrix <- rbind(c(1,.5),c(-.2,.3))
innovar.matrix <- diag(N)
true.psi <- var.par2pre(array(phi.matrix,c(2,2,1)))
gamma <- VARMAauto(array(phi.matrix,c(2,2,1)),NULL,innovar.matrix,10)
gamma.0 <- gamma[,,1]
x.init <- t(chol(gamma.0)) %*% rnorm(N)
# set directory to GitHub/MDFA-Legacy
setwd("C:/Users/neide/Documents/GitHub/MDFA-Legacy")
# set directory to GitHub/MDFA-Legacy
setwd("C:/Users/neide/OneDrive/Documents/GitHub/MDFA-Legacy")
path.main <- paste(getwd(),"/Sweave/",sep="")
path.pgm <- paste(path.main,"Rnw/",sep="")
path.out <- paste(path.main,"Latex/",sep="")
## Load MDFA R codes #
sourceDirectory(path=paste(path.main,"RcodeTSM/",sep=""), modifiedOnly=FALSE)
script <- paste(path.pgm,"MDFA_Legacy",sep="")
## enforce par(ask=FALSE)
options(device.ask.default=FALSE)
# Simulate a VAR(1) of sample size 5000:
set.seed(1234)
T <- 5000
N <- 2
levels <- c(1,2)
slopes <- c(-2,1)/1000
phi.matrix <- rbind(c(1,.5),c(-.2,.3))
innovar.matrix <- diag(N)
true.psi <- var.par2pre(array(phi.matrix,c(2,2,1)))
gamma <- VARMAauto(array(phi.matrix,c(2,2,1)),NULL,innovar.matrix,10)
gamma.0 <- gamma[,,1]
x.init <- t(chol(gamma.0)) %*% rnorm(N)
x.next <- x.init
x.sim <- NULL
for(t in 1:T)
{
x.next <- phi.matrix %*% x.next + t(chol(innovar.matrix)) %*% rnorm(N)
x.sim <- cbind(x.sim,x.next)
}
x.sim <- ts(t(x.sim))
time.trend <- seq(1,T)
x.sim <- t(levels) %x% rep(1,T) + t(slopes) %x% seq(1,T) + x.sim
sim.ols <- lm(x.sim ~ time.trend)
x.resid <- sim.ols$residuals
# construct and apply low pass filter
mu <- pi/6
len <- 1000
lp.filter <- c(mu/pi,sin(seq(1,len)*mu)/(pi*seq(1,len)))
lp.filter <- c(rev(lp.filter),lp.filter[-1])
x.trend.ideal <- mvar.filter(x.sim,array(t(lp.filter) %x% diag(N),c(N,N,(2*len+1))))
# get MDFA concurrent filter
q <- 30
grid <- T
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# frf for ideal low-pass
frf.psi <- rep(0,grid)
frf.psi[abs(freq.ft) <= mu] <- 1
frf.psi <- matrix(frf.psi,nrow=1) %x% diag(N)
frf.psi <- array(frf.psi,c(N,N,grid))
spec.hat <- mdfa.pergram(x.resid,1)
lp.mdfa.uc <- mdfa.unconstrained(frf.psi,spec.hat,q)
lp.mdfa.lc <- mdfa.levelconstraint(frf.psi,spec.hat,q)
lp.mdfa.tsc <- mdfa.tsconstraint(frf.psi,spec.hat,q)
lp.mdfa.ltsc <- mdfa.ltsconstraint(frf.psi,spec.hat,q)
# case 1: apply the unconstrained MDFA concurrent filter
x.trend.mdfa <- mvar.filter(x.sim,lp.mdfa.uc[[1]])[(len-q+2):(T-q+1-len),]
# compare in-sample performance
print(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)))
# compare to criterion value
diag(lp.mdfa.uc[[2]])
# case 2: apply the lc MDFA concurrent filter
x.trend.mdfa <- mvar.filter(x.sim,lp.mdfa.lc[[1]])[(len-q+2):(T-q+1-len),]
# compare in-sample performance
print(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)))
# compare to criterion value
diag(lp.mdfa.lc[[2]])
# case 3: apply the tsc MDFA concurrent filter
x.trend.mdfa <- mvar.filter(x.sim,lp.mdfa.tsc[[1]])[(len-q+2):(T-q+1-len),]
# compare in-sample performance
print(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)))
# compare to criterion value
diag(lp.mdfa.tsc[[2]])
# case 4: apply the ltsc MDFA concurrent filter
x.trend.mdfa <- mvar.filter(x.sim,lp.mdfa.ltsc[[1]])[(len-q+2):(T-q+1-len),]
# compare in-sample performance
print(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)))
# compare to criterion value
diag(lp.mdfa.ltsc[[2]])
# Simulate a Gaussian RW of sample size 5000:
set.seed(1234)
T.sim <- 5000
burn <- 1000
N <- 2
dpoly <- c(1,-1)
delta <- array(t(dpoly) %x% diag(N),c(N,N,2))
d <- length(dpoly) - 1
z.sim <- mdfa.wnsim(rep(0,3),rep(1,N),T.sim+burn,Inf)
Sigma <- z.sim[[2]]
x.sim <- mdfa.ucsim(delta,z.sim[[1]])[(burn+1-d):(T.sim+burn-d),]
# construct and apply ideal low-pass filter
mu <- pi/6
len <- 1000
lp.filter <- c(mu/pi,sin(seq(1,len)*mu)/(pi*seq(1,len)))
lp.filter <- c(rev(lp.filter),lp.filter[-1])
x.trend.ideal <- mvar.filter(x.sim,array(t(lp.filter) %x% diag(N),c(N,N,(2*len+1))))
# get MDFA concurrent filter
q <- 30
x.diff <- filter(x.sim,dpoly,method="convolution",sides=1)[(d+1):T.sim,]
spec.hat <- mdfa.pergram(x.diff,dpoly)
grid <- T.sim - d
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# another way???
frf.psi <- rep(0,grid)
frf.psi[abs(freq.ft) <= mu] <- 1
frf.psi.sharp <- (frf.psi - frf.psi[m+1])/(exp(-1i*freq.ft)-1)
frf.psi.sharp[m+1] <- 0
frf.psi.sharp <- matrix(frf.psi.sharp,nrow=1) %x% diag(N)
frf.psi.sharp <- array(frf.psi.sharp,c(N,N,grid))
frf.psi <- matrix(frf.psi,nrow=1) %x% diag(N)
frf.psi <- array(frf.psi,c(N,N,grid))
spec.hat.sharp <- mdfa.pergram(x.diff,1)
bw.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-1)
R.mat <- toeplitz(c(-1,1,rep(0,q-2)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-q] %x% diag(N)
Q.mat <- c(1,rep(0,q-1)) %x% frf.psi[,,m+1]
bw.mdfa.filter <- array(t(R.mat %*% t(matrix(bw.mdfa.sharp[[1]],nrow=N)) + Q.mat),c(N,N,q))
x.trend.mdfa <- mvar.filter(x.sim,bw.mdfa.filter)[(len-q+2):(T-q+1-len),]
# compare in-sample performance
print(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)))
# compare to criterion value
diag(bw.mdfa[[2]])
# frf for ideal low-pass
frf.psi <- rep(0,grid)
frf.psi[abs(freq.ft) <= mu] <- 1
frf.psi <- matrix(frf.psi,nrow=1) %x% diag(N)
frf.psi <- array(frf.psi,c(N,N,grid))
constraints.mdfa <- mdfa.getconstraints(frf.psi,0,NULL,0*diag(N),q)
bw.mdfa <- mdfa.filter(frf.psi,spec.hat,constraints.mdfa[[1]],constraints.mdfa[[2]])
x.trend.mdfa <- mvar.filter(x.sim,bw.mdfa[[1]])[(len-q+2):(T-q+1-len),]
# another way???
frf.psi <- rep(0,grid)
frf.psi[abs(freq.ft) <= mu] <- 1
frf.psi.sharp <- (frf.psi - frf.psi[m+1])/(exp(-1i*freq.ft)-1)
frf.psi.sharp[m+1] <- 0
frf.psi.sharp <- matrix(frf.psi.sharp,nrow=1) %x% diag(N)
frf.psi.sharp <- array(frf.psi.sharp,c(N,N,grid))
frf.psi <- matrix(frf.psi,nrow=1) %x% diag(N)
frf.psi <- array(frf.psi,c(N,N,grid))
bw.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-1)
R.mat <- toeplitz(c(-1,1,rep(0,q-2)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-q] %x% diag(N)
Q.mat <- c(1,rep(0,q-1)) %x% frf.psi[,,m+1]
bw.mdfa.filter <- array(t(R.mat %*% t(matrix(bw.mdfa.sharp[[1]],nrow=N)) + Q.mat),c(N,N,q))
x.trend.mdfa <- mvar.filter(x.sim,bw.mdfa.filter)[(len-q+2):(T-q+1-len),]
# compare in-sample performance
print(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)))
# compare to criterion value
diag(bw.mdfa[[2]])
# compare to criterion value
diag(bw.mdfa.sharp[[2]])
# Simulate an integrated VAR(1) of sample size 5000:
set.seed(1234)
T.sim <- 5000
burn <- 1000
N <- 2
rho <- .95
theta <- pi/24
phi <- matrix(c(rho*cos(theta),rho*sin(theta),-rho*sin(theta),rho*cos(theta)),c(2,2))
phi.array <- array(cbind(diag(N),-1*phi),c(N,N,2))
dpoly <- c(1,-1)
delta <- array(t(dpoly) %x% diag(N),c(N,N,2))
d <- length(dpoly) - 1
z.sim <- mdfa.wnsim(rep(0,3),rep(1,N),T.sim+burn,Inf)
Sigma <- z.sim[[2]]
var.sim <- mdfa.ucsim(phi.array,z.sim[[1]])
x.sim <- mdfa.ucsim(delta,var.sim)[(burn+1-d-2):(T.sim+burn-d-2),]
# construct and apply ideal band-pass filter
mu <- pi/60
eta <- pi/12
len <- 1000
bp.filter <- c(eta/pi,sin(seq(1,len)*eta)/(pi*seq(1,len))) -
c(mu/pi,sin(seq(1,len)*mu)/(pi*seq(1,len)))
bp.filter <- c(rev(bp.filter),bp.filter[-1])
x.cycle.ideal <- filter(x.sim,bp.filter,method="convolution",sides=2)[(len+1):(T-len),]
# get MDFA concurrent filter
q <- 20
x.diff <- filter(x.sim,dpoly,method="convolution",sides=1)[(d+1):T.sim,]
grid <- T.sim - d
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# frf for ideal band-pass
frf.psi <- rep(0,grid)
frf.psi[(abs(freq.ft) >= mu) & (abs(freq.ft) <= eta)] <- 1
frf.psi.sharp <- (frf.psi - frf.psi[m+1])/(exp(-1i*freq.ft)-1)
frf.psi.sharp[m+1] <- 0
frf.psi.sharp <- matrix(frf.psi.sharp,nrow=1) %x% diag(N)
frf.psi.sharp <- array(frf.psi.sharp,c(N,N,grid))
frf.psi <- matrix(frf.psi,nrow=1) %x% diag(N)
frf.psi <- array(frf.psi,c(N,N,grid))
spec.hat.sharp <- mdfa.pergram(x.diff,1)
bw.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-1)
R.mat <- toeplitz(c(-1,1,rep(0,q-2)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-q] %x% diag(N)
Q.mat <- c(1,rep(0,q-1)) %x% frf.psi[,,m+1]
bw.mdfa.filter <- array(t(R.mat %*% t(matrix(bw.mdfa.sharp[[1]],nrow=N)) + Q.mat),c(N,N,q))
x.trend.mdfa <- mvar.filter(x.sim,bw.mdfa.filter)[(len-q+2):(T-q+1-len),]
# compare in-sample performance
print(c(mean((x.cycle.ideal[,1] - x.cycle.mdfa[,1])^2),
mean((x.cycle.ideal[,2] - x.cycle.mdfa[,2])^2)))
bp.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-1)
R.mat <- toeplitz(c(-1,1,rep(0,q-2)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-q] %x% diag(N)
Q.mat <- c(1,rep(0,q-1)) %x% frf.psi[,,m+1]
bp.mdfa.filter <- array(t(R.mat %*% t(matrix(bp.mdfa.sharp[[1]],nrow=N)) + Q.mat),c(N,N,q))
x.cycle.mdfa <- mvar.filter(x.sim,bp.mdfa.filter)[(len-q+2):(T-q+1-len),]
# compare in-sample performance
print(c(mean((x.cycle.ideal[,1] - x.cycle.mdfa[,1])^2),
mean((x.cycle.ideal[,2] - x.cycle.mdfa[,2])^2)))
# compare to criterion value
diag(bp.mdfa.sharp[[2]])
# get MDFA concurrent filter
q <- 30
bp.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-1)
R.mat <- toeplitz(c(-1,1,rep(0,q-2)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-q] %x% diag(N)
Q.mat <- c(1,rep(0,q-1)) %x% frf.psi[,,m+1]
bp.mdfa.filter <- array(t(R.mat %*% t(matrix(bp.mdfa.sharp[[1]],nrow=N)) + Q.mat),c(N,N,q))
x.cycle.mdfa <- mvar.filter(x.sim,bp.mdfa.filter)[(len-q+2):(T-q+1-len),]
# compare in-sample performance
print(c(mean((x.cycle.ideal[,1] - x.cycle.mdfa[,1])^2),
mean((x.cycle.ideal[,2] - x.cycle.mdfa[,2])^2)))
# compare to criterion value
diag(bp.mdfa.sharp[[2]])
frf.psi[,,m+1]
dim(bp.mdfa.sharp[[1]])
plot.ts(bp.mdfa.sharp[[1]][1,1,])
plot.ts(bp.mdfa.sharp[[1]][2,2,])
# get MDFA concurrent filter
q <- 60
x.diff <- filter(x.sim,dpoly,method="convolution",sides=1)[(d+1):T.sim,]
grid <- T.sim - d
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# frf for ideal band-pass
frf.psi <- rep(0,grid)
frf.psi[(abs(freq.ft) >= mu) & (abs(freq.ft) <= eta)] <- 1
frf.psi.sharp <- (frf.psi - frf.psi[m+1])/(exp(-1i*freq.ft)-1)
frf.psi.sharp[m+1] <- 0
frf.psi.sharp <- matrix(frf.psi.sharp,nrow=1) %x% diag(N)
frf.psi.sharp <- array(frf.psi.sharp,c(N,N,grid))
frf.psi <- matrix(frf.psi,nrow=1) %x% diag(N)
bp.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-1)
R.mat <- toeplitz(c(-1,1,rep(0,q-2)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-q] %x% diag(N)
Q.mat <- c(1,rep(0,q-1)) %x% frf.psi[,,m+1]
frf.psi <- array(frf.psi,c(N,N,grid))
bp.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-1)
R.mat <- toeplitz(c(-1,1,rep(0,q-2)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-q] %x% diag(N)
Q.mat <- c(1,rep(0,q-1)) %x% frf.psi[,,m+1]
bp.mdfa.filter <- array(t(R.mat %*% t(matrix(bp.mdfa.sharp[[1]],nrow=N)) + Q.mat),c(N,N,q))
x.cycle.mdfa <- mvar.filter(x.sim,bp.mdfa.filter)[(len-q+2):(T-q+1-len),]
# compare in-sample performance
print(c(mean((x.cycle.ideal[,1] - x.cycle.mdfa[,1])^2),
mean((x.cycle.ideal[,2] - x.cycle.mdfa[,2])^2)))
# compare to criterion value
diag(bp.mdfa.sharp[[2]])
# get MDFA concurrent filter
q <- 100
x.diff <- filter(x.sim,dpoly,method="convolution",sides=1)[(d+1):T.sim,]
grid <- T.sim - d
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# frf for ideal band-pass
frf.psi <- rep(0,grid)
frf.psi[(abs(freq.ft) >= mu) & (abs(freq.ft) <= eta)] <- 1
frf.psi.sharp <- (frf.psi - frf.psi[m+1])/(exp(-1i*freq.ft)-1)
frf.psi.sharp[m+1] <- 0
frf.psi.sharp <- matrix(frf.psi.sharp,nrow=1) %x% diag(N)
frf.psi.sharp <- array(frf.psi.sharp,c(N,N,grid))
frf.psi <- matrix(frf.psi,nrow=1) %x% diag(N)
frf.psi <- array(frf.psi,c(N,N,grid))
bp.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-1)
R.mat <- toeplitz(c(-1,1,rep(0,q-2)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-q] %x% diag(N)
Q.mat <- c(1,rep(0,q-1)) %x% frf.psi[,,m+1]
bp.mdfa.filter <- array(t(R.mat %*% t(matrix(bp.mdfa.sharp[[1]],nrow=N)) + Q.mat),c(N,N,q))
x.cycle.mdfa <- mvar.filter(x.sim,bp.mdfa.filter)[(len-q+2):(T-q+1-len),]
# compare in-sample performance
print(c(mean((x.cycle.ideal[,1] - x.cycle.mdfa[,1])^2),
mean((x.cycle.ideal[,2] - x.cycle.mdfa[,2])^2)))
# compare to criterion value
diag(bp.mdfa.sharp[[2]])
plot.ts(bp.mdfa.filter[[1]][1,1,])
plot.ts(bp.mdfa.sharp[[1]][1,1,])
plot.ts(bp.mdfa.filter[1,1,])
# get MDFA concurrent filter
q <- 10
x.diff <- filter(x.sim,dpoly,method="convolution",sides=1)[(d+1):T.sim,]
grid <- T.sim - d
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# frf for ideal band-pass
frf.psi <- rep(0,grid)
frf.psi[(abs(freq.ft) >= mu) & (abs(freq.ft) <= eta)] <- 1
frf.psi.sharp <- (frf.psi - frf.psi[m+1])/(exp(-1i*freq.ft)-1)
frf.psi.sharp[m+1] <- 0
frf.psi.sharp <- matrix(frf.psi.sharp,nrow=1) %x% diag(N)
frf.psi.sharp <- array(frf.psi.sharp,c(N,N,grid))
frf.psi <- matrix(frf.psi,nrow=1) %x% diag(N)
frf.psi <- array(frf.psi,c(N,N,grid))
bp.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-1)
R.mat <- toeplitz(c(-1,1,rep(0,q-2)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-q] %x% diag(N)
Q.mat <- c(1,rep(0,q-1)) %x% frf.psi[,,m+1]
bp.mdfa.filter <- array(t(R.mat %*% t(matrix(bp.mdfa.sharp[[1]],nrow=N)) + Q.mat),c(N,N,q))
x.cycle.mdfa <- mvar.filter(x.sim,bp.mdfa.filter)[(len-q+2):(T-q+1-len),]
# compare in-sample performance
print(c(mean((x.cycle.ideal[,1] - x.cycle.mdfa[,1])^2),
mean((x.cycle.ideal[,2] - x.cycle.mdfa[,2])^2)))
# compare to criterion value
diag(bp.mdfa.sharp[[2]])
plot.ts(bp.mdfa.filter[1,1,])
# get MDFA concurrent filter
q <- 20
x.diff <- filter(x.sim,dpoly,method="convolution",sides=1)[(d+1):T.sim,]
grid <- T.sim - d
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# frf for ideal band-pass
frf.psi <- rep(0,grid)
frf.psi[(abs(freq.ft) >= mu) & (abs(freq.ft) <= eta)] <- 1
frf.psi.sharp <- (frf.psi - frf.psi[m+1])/(exp(-1i*freq.ft)-1)
frf.psi.sharp[m+1] <- 0
frf.psi.sharp <- matrix(frf.psi.sharp,nrow=1) %x% diag(N)
frf.psi.sharp <- array(frf.psi.sharp,c(N,N,grid))
frf.psi <- matrix(frf.psi,nrow=1) %x% diag(N)
frf.psi <- array(frf.psi,c(N,N,grid))
bp.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-1)
R.mat <- toeplitz(c(-1,1,rep(0,q-2)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-q] %x% diag(N)
Q.mat <- c(1,rep(0,q-1)) %x% frf.psi[,,m+1]
bp.mdfa.filter <- array(t(R.mat %*% t(matrix(bp.mdfa.sharp[[1]],nrow=N)) + Q.mat),c(N,N,q))
x.cycle.mdfa <- mvar.filter(x.sim,bp.mdfa.filter)[(len-q+2):(T-q+1-len),]
# compare in-sample performance
print(c(mean((x.cycle.ideal[,1] - x.cycle.mdfa[,1])^2),
mean((x.cycle.ideal[,2] - x.cycle.mdfa[,2])^2)))
# compare to criterion value
diag(bp.mdfa.sharp[[2]])
# get MDFA concurrent filter
q <- 15
x.diff <- filter(x.sim,dpoly,method="convolution",sides=1)[(d+1):T.sim,]
grid <- T.sim - d
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# frf for ideal band-pass
frf.psi <- rep(0,grid)
frf.psi[(abs(freq.ft) >= mu) & (abs(freq.ft) <= eta)] <- 1
frf.psi.sharp <- (frf.psi - frf.psi[m+1])/(exp(-1i*freq.ft)-1)
frf.psi.sharp[m+1] <- 0
frf.psi.sharp <- matrix(frf.psi.sharp,nrow=1) %x% diag(N)
frf.psi.sharp <- array(frf.psi.sharp,c(N,N,grid))
frf.psi <- matrix(frf.psi,nrow=1) %x% diag(N)
frf.psi <- array(frf.psi,c(N,N,grid))
bp.mdfa.sharp <- mdfa.unconstrained(frf.psi.sharp,spec.hat.sharp,q-1)
R.mat <- toeplitz(c(-1,1,rep(0,q-2)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-q] %x% diag(N)
Q.mat <- c(1,rep(0,q-1)) %x% frf.psi[,,m+1]
bp.mdfa.filter <- array(t(R.mat %*% t(matrix(bp.mdfa.sharp[[1]],nrow=N)) + Q.mat),c(N,N,q))
x.cycle.mdfa <- mvar.filter(x.sim,bp.mdfa.filter)[(len-q+2):(T-q+1-len),]
# compare in-sample performance
print(c(mean((x.cycle.ideal[,1] - x.cycle.mdfa[,1])^2),
mean((x.cycle.ideal[,2] - x.cycle.mdfa[,2])^2)))
# compare to criterion value
diag(bp.mdfa.sharp[[2]])
