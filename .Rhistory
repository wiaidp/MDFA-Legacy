gamma1 <- c((1+theta^3)*mu3, 2*(1+phi^2)^2*sigma2^2 + mu4*(1+theta^4),
2*phi*(1+phi^2)*sigma2^2 + mu4*theta^3, rep(0,N-3))
gamma2 <- c(theta^2*mu3,2*phi*(1+phi^2)*sigma2^2 + mu4*theta^3,
(phi^2 + (1+phi^2)^2)*sigma2^2 + mu4*theta^2,
phi*(1+phi^2)*sigma2^2,rep(0,N-4))
Gamma <- rbind(gamma2,Gamma)
Gamma <- rbind(gamma1,Gamma)
Gamma <- rbind(gamma0,Gamma)
xAcf[,1,] <- Gamma
Gamma <- toeplitz(c(phi^2*sigma2^2,phi*(1+phi^2)*sigma2^2,phi^2*sigma2^2,rep(0,N-6)))
Gamma[lower.tri(Gamma)] <- 0
Gamma <- cbind(rep(0,N-3),Gamma)
Gamma <- cbind(c(phi^2*sigma2^2,rep(0,N-4)),Gamma)
Gamma <- cbind(rep(0,N-3),Gamma)
gamma0 <- c(phi*sigma2,theta*mu3,rep(0,N-2))
gamma1 <- c(theta^2*mu3,2*phi^2*sigma2^2+mu4*theta^2,phi*(1+phi^2)*sigma2^2,
phi^2*sigma2^2,rep(0,N-4))
gamma2 <- c(theta*mu3,phi*(1+phi^2)*sigma2^2+mu4*theta,phi^2*sigma2^2,
phi*(1+phi^2)*sigma2^2,phi^2*sigma2^2,rep(0,N-5))
Gamma <- rbind(gamma2,Gamma)
Gamma <- rbind(gamma1,Gamma)
Gamma <- rbind(gamma0,Gamma)
xAcf[,2,] <- Gamma
## compute factorization
factor <- specFactmvar(xAcf,loud=FALSE)
theta.vma <- factor[[1]][,,2:1]
sigma.vma <- factor[[2]]
## quadratic mse divided by linear mse
print(sigma.vma[1,1]/sigma2)
}
## filter coefficients
trunc <- 20
coeff <- theta.vma[,,2]
quad.filter <- array(0,c(trunc+1,N))
quad.filter[1,] <- coeff[1,]
for(j in 1:trunc)
{
coeff <- -1*theta.vma[,,2] %*% coeff
quad.filter[j+1,] <- coeff[1,]
}
print(round(quad.filter,digits=4))
seq(0,trunc)
library(xtable)
## filter coefficients
trunc <- 20
coeff <- theta.vma[,,2]
quad.filter <- array(0,c(trunc+1,N))
quad.filter[1,] <- coeff[1,]
for(j in 1:trunc)
{
coeff <- -1*theta.vma[,,2] %*% coeff
quad.filter[j+1,] <- coeff[1,]
}
out.table <- round(quad.filter,digits=4)
rownames(out.table) <- seq(0,trunc)
print(xtable(out.table))
out.table <- round(quad.filter,digits=6)
rownames(out.table) <- seq(0,trunc)
print(xtable(out.table))
## filter coefficients
trunc <- 20
coeff <- theta.vma[,,2]
quad.filter <- matrix(0,nrow=trunc+1,ncol=N)
quad.filter[1,] <- coeff[1,]
for(j in 1:trunc)
{
coeff <- -1*theta.vma[,,2] %*% coeff
quad.filter[j+1,] <- coeff[1,]
}
rownames(quad.filter) <- seq(0,trunc)
print(xtable(quad.filter),digits=4)
print(xtable(quad.filter,digits=4))
tau
# stdev of Gaussian white noise
tau <- 0
# moments of centered degree 1 chi square
mu2 <- 2
mu3 <- 8
mu4 <- 48
# moving average parameter
theta <- -.8
## compute new parameters
rho1 <- mu2*theta/(mu2*(1+theta^2)+tau^2)
phi.pos <- (1 + sqrt(1-4*rho1^2))/(2*rho1)
phi.neg <- (1 - sqrt(1-4*rho1^2))/(2*rho1)
if(abs(phi.pos)< 1) { phi <- phi.pos } else { phi <- phi.neg }
sigma2 <- mu2*theta/phi
## check
mu2*polymult(c(1,theta),rev(c(1,theta))) + c(0,tau^2,0)
sigma2*polymult(c(1,phi),rev(c(1,phi)))
## Compute acvf
# set truncation N > 4
N <- 10
xAcf <- array(0,c(N,2,N))
Gamma <- toeplitz(c((1+phi^2)^2*sigma2^2,
phi*(1+phi^2)*sigma2^2, rep(0,N-5)))
Gamma <- cbind(c(phi*(1+phi^2)*sigma2^2,rep(0,N-4)),Gamma)
Gamma <- cbind(rep(0,N-3),Gamma)
Gamma <- cbind(rep(0,N-3),Gamma)
gamma0 <- c((1+phi^2)*sigma2, (1+theta^3)*mu3, theta^2*mu3, rep(0,N-3))
gamma1 <- c((1+theta^3)*mu3, 2*(1+phi^2)^2*sigma2^2 + mu4*(1+theta^4),
2*phi*(1+phi^2)*sigma2^2 + mu4*theta^3, rep(0,N-3))
gamma2 <- c(theta^2*mu3,2*phi*(1+phi^2)*sigma2^2 + mu4*theta^3,
(phi^2 + (1+phi^2)^2)*sigma2^2 + mu4*theta^2,
phi*(1+phi^2)*sigma2^2,rep(0,N-4))
Gamma <- rbind(gamma2,Gamma)
Gamma <- rbind(gamma1,Gamma)
Gamma <- rbind(gamma0,Gamma)
xAcf[,1,] <- Gamma
Gamma <- toeplitz(c(phi^2*sigma2^2,phi*(1+phi^2)*sigma2^2,phi^2*sigma2^2,rep(0,N-6)))
Gamma[lower.tri(Gamma)] <- 0
Gamma <- cbind(rep(0,N-3),Gamma)
Gamma <- cbind(c(phi^2*sigma2^2,rep(0,N-4)),Gamma)
Gamma <- cbind(rep(0,N-3),Gamma)
gamma0 <- c(phi*sigma2,theta*mu3,rep(0,N-2))
gamma1 <- c(theta^2*mu3,2*phi^2*sigma2^2+mu4*theta^2,phi*(1+phi^2)*sigma2^2,
phi^2*sigma2^2,rep(0,N-4))
gamma2 <- c(theta*mu3,phi*(1+phi^2)*sigma2^2+mu4*theta,phi^2*sigma2^2,
phi*(1+phi^2)*sigma2^2,phi^2*sigma2^2,rep(0,N-5))
Gamma <- rbind(gamma2,Gamma)
Gamma <- rbind(gamma1,Gamma)
Gamma <- rbind(gamma0,Gamma)
xAcf[,2,] <- Gamma
## compute factorization
factor <- specFactmvar(xAcf)
theta.vma <- factor[[1]][,,2:1]
sigma.vma <- factor[[2]]
## quadratic mse divided by linear mse
print(sigma.vma[1,1]/sigma2)
## filter coefficients
trunc <- 20
coeff <- theta.vma[,,2]
quad.filter <- matrix(0,nrow=trunc+1,ncol=N)
quad.filter[1,] <- coeff[1,]
for(j in 1:trunc)
{
coeff <- -1*theta.vma[,,2] %*% coeff
quad.filter[j+1,] <- coeff[1,]
}
rownames(quad.filter) <- seq(0,trunc)
print(xtable(quad.filter,digits=4))
tau <- 1
# moments of centered degree 1 chi square
mu2 <- 2
mu3 <- 8
mu4 <- 48
# moving average parameter
theta <- -.8
## compute new parameters
rho1 <- mu2*theta/(mu2*(1+theta^2)+tau^2)
phi.pos <- (1 + sqrt(1-4*rho1^2))/(2*rho1)
phi.neg <- (1 - sqrt(1-4*rho1^2))/(2*rho1)
if(abs(phi.pos)< 1) { phi <- phi.pos } else { phi <- phi.neg }
sigma2 <- mu2*theta/phi
## check
mu2*polymult(c(1,theta),rev(c(1,theta))) + c(0,tau^2,0)
sigma2*polymult(c(1,phi),rev(c(1,phi)))
## Compute acvf
# set truncation N > 4
N <- 10
xAcf <- array(0,c(N,2,N))
Gamma <- toeplitz(c((1+phi^2)^2*sigma2^2,
phi*(1+phi^2)*sigma2^2, rep(0,N-5)))
Gamma <- cbind(c(phi*(1+phi^2)*sigma2^2,rep(0,N-4)),Gamma)
Gamma <- cbind(rep(0,N-3),Gamma)
Gamma <- cbind(rep(0,N-3),Gamma)
gamma0 <- c((1+phi^2)*sigma2, (1+theta^3)*mu3, theta^2*mu3, rep(0,N-3))
gamma1 <- c((1+theta^3)*mu3, 2*(1+phi^2)^2*sigma2^2 + mu4*(1+theta^4),
2*phi*(1+phi^2)*sigma2^2 + mu4*theta^3, rep(0,N-3))
gamma2 <- c(theta^2*mu3,2*phi*(1+phi^2)*sigma2^2 + mu4*theta^3,
(phi^2 + (1+phi^2)^2)*sigma2^2 + mu4*theta^2,
phi*(1+phi^2)*sigma2^2,rep(0,N-4))
Gamma <- rbind(gamma2,Gamma)
Gamma <- rbind(gamma1,Gamma)
Gamma <- rbind(gamma0,Gamma)
xAcf[,1,] <- Gamma
Gamma <- toeplitz(c(phi^2*sigma2^2,phi*(1+phi^2)*sigma2^2,phi^2*sigma2^2,rep(0,N-6)))
Gamma[lower.tri(Gamma)] <- 0
Gamma <- cbind(rep(0,N-3),Gamma)
Gamma <- cbind(c(phi^2*sigma2^2,rep(0,N-4)),Gamma)
Gamma <- cbind(rep(0,N-3),Gamma)
gamma0 <- c(phi*sigma2,theta*mu3,rep(0,N-2))
gamma1 <- c(theta^2*mu3,2*phi^2*sigma2^2+mu4*theta^2,phi*(1+phi^2)*sigma2^2,
phi^2*sigma2^2,rep(0,N-4))
gamma2 <- c(theta*mu3,phi*(1+phi^2)*sigma2^2+mu4*theta,phi^2*sigma2^2,
phi*(1+phi^2)*sigma2^2,phi^2*sigma2^2,rep(0,N-5))
Gamma <- rbind(gamma2,Gamma)
Gamma <- rbind(gamma1,Gamma)
Gamma <- rbind(gamma0,Gamma)
xAcf[,2,] <- Gamma
## compute factorization
factor <- specFactmvar(xAcf)
theta.vma <- factor[[1]][,,2:1]
sigma.vma <- factor[[2]]
## quadratic mse divided by linear mse
print(sigma.vma[1,1]/sigma2)
## filter coefficients
trunc <- 20
coeff <- theta.vma[,,2]
quad.filter <- matrix(0,nrow=trunc+1,ncol=N)
quad.filter[1,] <- coeff[1,]
for(j in 1:trunc)
{
coeff <- -1*theta.vma[,,2] %*% coeff
quad.filter[j+1,] <- coeff[1,]
}
rownames(quad.filter) <- seq(0,trunc)
print(xtable(quad.filter,digits=4))
# stdev of Gaussian white noise
tau <- 2
# moments of centered degree 1 chi square
mu2 <- 2
mu3 <- 8
mu4 <- 48
# moving average parameter
theta <- -.8
## compute new parameters
rho1 <- mu2*theta/(mu2*(1+theta^2)+tau^2)
phi.pos <- (1 + sqrt(1-4*rho1^2))/(2*rho1)
phi.neg <- (1 - sqrt(1-4*rho1^2))/(2*rho1)
if(abs(phi.pos)< 1) { phi <- phi.pos } else { phi <- phi.neg }
sigma2 <- mu2*theta/phi
## check
mu2*polymult(c(1,theta),rev(c(1,theta))) + c(0,tau^2,0)
sigma2*polymult(c(1,phi),rev(c(1,phi)))
## Compute acvf
# set truncation N > 4
N <- 10
xAcf <- array(0,c(N,2,N))
Gamma <- toeplitz(c((1+phi^2)^2*sigma2^2,
phi*(1+phi^2)*sigma2^2, rep(0,N-5)))
Gamma <- cbind(c(phi*(1+phi^2)*sigma2^2,rep(0,N-4)),Gamma)
Gamma <- cbind(rep(0,N-3),Gamma)
Gamma <- cbind(rep(0,N-3),Gamma)
gamma0 <- c((1+phi^2)*sigma2, (1+theta^3)*mu3, theta^2*mu3, rep(0,N-3))
gamma1 <- c((1+theta^3)*mu3, 2*(1+phi^2)^2*sigma2^2 + mu4*(1+theta^4),
2*phi*(1+phi^2)*sigma2^2 + mu4*theta^3, rep(0,N-3))
gamma2 <- c(theta^2*mu3,2*phi*(1+phi^2)*sigma2^2 + mu4*theta^3,
(phi^2 + (1+phi^2)^2)*sigma2^2 + mu4*theta^2,
phi*(1+phi^2)*sigma2^2,rep(0,N-4))
Gamma <- rbind(gamma2,Gamma)
Gamma <- rbind(gamma1,Gamma)
Gamma <- rbind(gamma0,Gamma)
xAcf[,1,] <- Gamma
Gamma <- toeplitz(c(phi^2*sigma2^2,phi*(1+phi^2)*sigma2^2,phi^2*sigma2^2,rep(0,N-6)))
Gamma[lower.tri(Gamma)] <- 0
Gamma <- cbind(rep(0,N-3),Gamma)
Gamma <- cbind(c(phi^2*sigma2^2,rep(0,N-4)),Gamma)
Gamma <- cbind(rep(0,N-3),Gamma)
gamma0 <- c(phi*sigma2,theta*mu3,rep(0,N-2))
gamma1 <- c(theta^2*mu3,2*phi^2*sigma2^2+mu4*theta^2,phi*(1+phi^2)*sigma2^2,
phi^2*sigma2^2,rep(0,N-4))
gamma2 <- c(theta*mu3,phi*(1+phi^2)*sigma2^2+mu4*theta,phi^2*sigma2^2,
phi*(1+phi^2)*sigma2^2,phi^2*sigma2^2,rep(0,N-5))
Gamma <- rbind(gamma2,Gamma)
Gamma <- rbind(gamma1,Gamma)
Gamma <- rbind(gamma0,Gamma)
xAcf[,2,] <- Gamma
## compute factorization
factor <- specFactmvar(xAcf)
theta.vma <- factor[[1]][,,2:1]
sigma.vma <- factor[[2]]
## quadratic mse divided by linear mse
print(sigma.vma[1,1]/sigma2)
## filter coefficients
trunc <- 20
coeff <- theta.vma[,,2]
quad.filter <- matrix(0,nrow=trunc+1,ncol=N)
quad.filter[1,] <- coeff[1,]
for(j in 1:trunc)
{
coeff <- -1*theta.vma[,,2] %*% coeff
quad.filter[j+1,] <- coeff[1,]
}
rownames(quad.filter) <- seq(0,trunc)
print(xtable(quad.filter,digits=4))
rm(list=ls())
library(xts)
# State-space models (will be replicated by MDFA)
library(dlm)
# Numerical package
library(numDeriv)
# Graphical package for recession-shading (empirical examples based on US-GDP)
library(tis)
#install.packages("devtools")
library(devtools)
# Load MDFA package from github
devtools::install_github("wiaidp/MDFA")
# MDFA package
library(MDFA)
library(mFilter)  # Classic filter designs (be replicated by MDFA)
library(RCurl)    # For getURL() and curl handler / cookie / google login
library(stringr)  # For str_trim() to trip whitespace from strings
library(Quandl)
require (Quandl)
#Quandl.api_key("ivVdJGV57TXA1RX5jgvp")
#  Tucker's libraries
library(expm)
library(R.utils)
library(xtable)
# set directory to GitHub/MDFA-Legacy
setwd("C:/Users/neide/OneDrive/Documents/GitHub/MDFA-Legacy")
path.main <- paste(getwd(),"/Sweave/",sep="")
path.pgm <- paste(path.main,"Rnw/",sep="")
path.out <- paste(path.main,"Latex/",sep="")
## Load MDFA R codes #
sourceDirectory(path=paste(path.main,"RcodeTSM/",sep=""), modifiedOnly=FALSE)
# Simulate a Gaussian VAR(1) of sample size 5000:
set.seed(1234)
burnin <- 10000
T.sim <- 5000
N <- 2
phi.matrix <- rbind(c(1/3,2/9),c(2,1/3))
out.svd <- svd(phi.matrix - diag(N))
alpha <- out.svd$u[,1,drop=FALSE] * sqrt(out.svd$d[1])
beta <- out.svd$v[,1,drop=FALSE] * sqrt(out.svd$d[1])
innovar.matrix <- diag(N)
x.init <- rep(0,N)
x.next <- x.init
x.sim <- NULL
for(t in 1:(T.sim+burnin))
{
x.next <- phi.matrix %*% x.next + t(chol(innovar.matrix)) %*% rnorm(N)
x.sim <- cbind(x.sim,x.next)
}
x.sim <- ts(t(x.sim[,-seq(1,burnin)]))
# construct and apply low pass filter
mu <- pi/6
len <- 1000
dpoly <- c(1,-1)
d <- length(dpoly) - 1
delta <- array(t(dpoly) %x% diag(N),c(N,N,d+1))
lp.filter <- c(mu/pi,sin(seq(1,len)*mu)/(pi*seq(1,len)))
lp.filter <- c(rev(lp.filter),lp.filter[-1])
x.lp.ideal <- mvar.filter(x.sim,array(t(lp.filter) %x% diag(N),c(N,N,(2*len+1))))
# get differenced data and partially differenced co-int aggregated data;
#  strip the latter's first observation to make sample size match grid
q <- 30
x.diff <- filter(x.sim,dpoly,method="convolution",sides=1)[(d+1):T.sim,]
x.all <- cbind(x.sim[-1,] %*% beta,x.diff)
grid <- T.sim - d
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# frf for ideal low-pass
frf.psi <- rep(0,grid)
frf.psi[abs(freq.ft) <= mu] <- 1
frf.psi <- matrix(frf.psi,nrow=1) %x% diag(N)
frf.psi <- array(frf.psi,c(N,N,grid))
frf.deltan <- matrix(rep(1,grid),nrow=1) %x% diag(N)
frf.deltan <- array(frf.deltan,c(N,N,grid))
# for low pass frf get psi sharp, psi star, and coint vec;
#  modify psi sharp by coint constraint
rootfreqs <- 0
rem.vec <- mdfa.getremainder(frf.psi,rootfreqs)
frf.psi.sharp <- mdfa.getquotient(frf.psi,rootfreqs,rem.vec)
coint.vec <- mdfa.getremainder(frf.deltan,rootfreqs)
coint.coeff <- (diag(N) - coint.vec[1:N,,drop=FALSE]) %*% alpha %*% t(beta)
frf.coint <- array(rep(1,grid) %x% coint.coeff,c(N,N,grid))
frf.psi.flat <- frf.psi.sharp - frf.coint
# get mdfa filter and output
spec.hat.sharp <- mdfa.pergram(x.all,1)
lp.mdfa.sharp <- mdfa.coint(frf.psi.flat,spec.hat.sharp[-1,-1,],
spec.hat.sharp[1,-1,,drop=FALSE],alpha,q-d)
R.mat <- toeplitz(c(rev(dpoly),rep(0,q-d-1)))
R.mat[upper.tri(R.mat)] <- 0
R.mat <- R.mat[,-seq(q-d+1,q)] %x% diag(N)
Q.mat <- rbind(rem.vec - coint.vec %*% alpha %*% t(beta), matrix(0,nrow=N*(q-d),ncol=N))
lp.mdfa.filter <- array(t(R.mat %*% t(matrix(lp.mdfa.sharp,nrow=N))
+ Q.mat),c(N,N,q))
x.lp.mdfa <- mvar.filter(x.sim,lp.mdfa.filter)[(len-q+2):(T.sim-q+1-len),]
# compare in-sample performance
print(c(mean((x.lp.ideal[,1] - x.lp.mdfa[,1])^2),
mean((x.lp.ideal[,2] - x.lp.mdfa[,2])^2)))
plot.ts(x.lp.ideal[,1])
lines(x.lp.mdfa[,2])
lines(x.lp.mdfa[,1])
plot.ts(x.lp.ideal[,1])
lines(x.lp.mdfa[,1])
plot.ts(x.lp.ideal[,1]/x.lp.mdfa[,1])
x.lp.ideal[1:10,1]/x.lp.mdfa[1:10,1]
alpha
beta
alpha %*% t(beta)
dim(rem.vec)
dim(frf.psi.sharp)
rem.vec
(1-freq.ft[k])*frf.psi.sharp[,,k] + rem.vec
k <- 10
(1-freq.ft[k])*frf.psi.sharp[,,k] + rem.vec
frf.psi[,,k]
(1-exp(-1i*freq.ft[k]))*frf.psi.sharp[,,k] + rem.vec
frf
frf <- frf.psi
N <- dim(frf)[1]
grid <- dim(frf)[3]
m <- floor(grid/2)
d <- length(rootfreqs)
sig.lambdas <- unique(rootfreqs)
sig.mults <- NULL
if(length(rootfreqs)>0)
{
for(j in 1:length(sig.lambdas))
{
sig.mults <- c(sig.mults,sum(rootfreqs == sig.lambdas[j]))
}
}
sig.vec <- NULL
if(length(sig.lambdas) > 0) {
for(k in 1:length(sig.lambdas))
{
j.star <- floor(sig.lambdas[k]*grid/2) + m+1
if(j.star==(grid+1)) j.star <- 1
sig.vec.new <- frf[,,j.star]
sig.vec <- rbind(sig.vec,t(sig.vec.new))
if(sig.mults[k]==2)
{
if(j.star==grid)
{
sig.vec.new <- 1i*exp(1i*sig.lambdas[k]*pi)*
(frf[,,1]-frf[,,j.star])*grid/(2*pi)
} else
{
sig.vec.new <- 1i*exp(1i*sig.lambdas[k]*pi)*
(frf[,,j.star+1]-frf[,,j.star])*grid/(2*pi)
}
sig.vec <- rbind(sig.vec,t(sig.vec.new))
}
}
}
sig.lambdas
W.mat <- NULL
for(j in 1:length(sig.lambdas))
{
zeta <- exp(1i*pi*sig.lambdas[j])
for(k in 1:sig.mults[j])
{
weights <- c(rep(0,k-1),factorial(k-1)*choose(seq(k-1,d-1),k-1))
W.mat <- rbind(W.mat,weights*zeta^(seq(1,d)-k))
}
}
W.mat
ceps2wold <- function(ceps,q)
{
m <- length(ceps)
if(q > m) { ceps <- c(ceps,rep(0,q-m)) }
wold <- 1
wolds <- wold
for(j in 1:q)
{
wold <- sum(seq(1,j)*ceps[1:j]*wolds[j:1])/j
wolds <- c(wolds,wold)
}
return(wolds)
}
roots2ceps <- function(roots,m)
{
p <- length(roots)
ceps <- rep(0,m)
for(k in 1:m)
{
ceps[k] <- -1*sum(roots^(-k))/k
}
return(ceps)
}
N <- dim(frf.psi)[1]
grid <- dim(frf.psi)[3]
m <- floor(grid/2)
d <- length(rootfreqs)
sig.lambdas <- unique(rootfreqs)
# Find frequencies on grid closest to the root frequencies
j.stars <- NULL
if(length(sig.lambdas) > 0) {
for(k in 1:length(sig.lambdas))
{
j.star <- floor(sig.lambdas[k]*grid/2) + m+1
if(j.star==(grid+1)) j.star <- 1
j.stars <- c(j.stars,j.star)
}
}
j.stars
freq.ft[j.star]
root.ceps <- Re(roots2ceps(exp(-1i*pi*rootfreqs),length(rootfreqs)))
ceps2wold(root.ceps,length(rootfreqs))
delta
delta <- ceps2wold(root.ceps,length(rootfreqs))
delta <- delta/delta[d+1]
rootfreqs
rootfreqs <- c(0,1/6.1/6)
root.ceps <- Re(roots2ceps(exp(-1i*pi*rootfreqs),length(rootfreqs)))
delta <- ceps2wold(root.ceps,length(rootfreqs))
delta <- delta/delta[d+1]
roots2ceps(exp(-1i*pi*rootfreqs),length(rootfreqs))
rootfreqs <- c(0,1/6,-1/6)
roots2ceps(exp(-1i*pi*rootfreqs),length(rootfreqs))
root.ceps <- Re(roots2ceps(exp(-1i*pi*rootfreqs),length(rootfreqs)))
delta <- ceps2wold(root.ceps,length(rootfreqs))
delta <- delta/delta[d+1]
rootfreqs <- c(1/6,-1/6)
root.ceps <- Re(roots2ceps(exp(-1i*pi*rootfreqs),length(rootfreqs)))
delta <- ceps2wold(root.ceps,length(rootfreqs))
delta <- delta/delta[d+1]
d <- length(rootfreqs)
root.ceps <- Re(roots2ceps(exp(-1i*pi*rootfreqs),length(rootfreqs)))
delta <- ceps2wold(root.ceps,length(rootfreqs))
delta <- delta/delta[d+1]
(1-exp(-1i*freq.ft[k]))*frf.psi.sharp[,,k] + rem.vec
(exp(-1i*freq.ft[k])-1)*frf.psi.sharp[,,k] + rem.vec
frf.psi[,,k]
help(tic)
library(tictoc)
help(tic)
