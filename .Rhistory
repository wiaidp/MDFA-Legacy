mtext(colnames(filter_mat)[i],col=colo[i],line=-i)
par(mfrow=c(1,2))
mplot<-scale(cbind(hp_trend,target,hp_gap,modified_hp_gap),center=F,scale=rep(T,4))
Sweave(script,output=paste(path.out,"MDFA_Legacy.tex",sep=""))
Sweave(script,output=paste(path.out,"MDFA_Legacy.tex",sep=""))
Sweave(script,output=paste(path.out,"MDFA_Legacy.tex",sep=""))
path.main
path.data<-paste(path.main,"Data/")
Sweave(script,output=paste(path.out,"MDFA_Legacy.tex",sep=""))
path.data<-paste(path.main,"Data/",sep="")
Sweave(script,output=paste(path.out,"MDFA_Legacy.tex",sep=""))
data_obj<-data_load_func(path.data)
# Data sent by Simon: log-returns, data from FRED
# Remove fourth series (INDPRO not seasonally adjusted: all other series are adjusted)
indpro<-data_obj$indpro[,-4]
indpro_level<-data_obj$indpro_level
# Second data sent by Simon: data from OECD, seasonally adjusted
# Data is shorter than FRED: for countries appearing in both data sets the longer series in FRED are selected
indpro_euh<-data_obj$indpro_eu
# Remove Spain and Japan which are contained in indpro (longer series there)
remove_series<-which(colnames(indpro_euh)%in%c("Japan","Spain"))
indpro_eu<-indpro_euh[,-remove_series]
# Select INDPRO and make xts object
select_series<-"US"
series_level<-indpro_level[,select_series]
series<-indpro[,select_series]
plot(series)
L<-200
lambda_monthly<-14400
HP_obj<-HP_target_mse_modified_gap(L,lambda_monthly)
target=HP_obj$target
hp_gap=HP_obj$hp_gap
modified_hp_gap=HP_obj$modified_hp_gap
hp_trend=HP_obj$hp_trend
hp_mse=HP_obj$hp_mse
#---------------------------
# 3. SSA and hyperparameters
# Holding time
ht<-12
forecast_horizon_vec<-c(0,18)
# White noise assumption: MA1_adjustment<-F (MA1_adjustment<-T is not used and should be checked)
MA1_adjustment<-F
# Size of discret grid for computing nu
grid_size<-200
# Computations are done if recompute_calculations==T (takes a couple seconds). Otherwise saved coefficients are loaded from path.result
SSA_obj<-SSA_compute(ht,L,hp_mse,forecast_horizon_vec,MA1_adjustment,grid_size)
source("C:/Users/marca/OneDrive/2023/Projects/MDFA-Legacy/Sweave/RcodeSSA/functions_SSA.R", echo=TRUE)
Sweave(script,output=paste(path.out,"MDFA_Legacy.tex",sep=""))
Sweave(script,output=paste(path.out,"MDFA_Legacy.tex",sep=""))
path.out
forecast_horizon<-0
# See 1. above
len<-L<-10
set.seed(1)
M<-matrix(nrow=L,ncol=L)
M[L,]<-rep(0,L)
M[L-1,]<-c(rep(0,L-1),0.5)
for (i in 1:(L-2))
M[i,]<-c(rep(0,i),0.5,rep(0,L-1-i))
M<-M+t(M)
eigen(M)$values
# Select gammak as second eigenvector of M
gammak<-gammak_generic<-eigen(M)$vector[,2]
eig<-eigen(M)
k<-3
ts.plot(eig$vectors[,k])
nu<-rnorm(1)
nu<-2
Nu<-2*M-nu*diag(rep(1,L))
# gammak is also eigenvector of Nu^{-1}
solve(Nu)%*%gammak/gammak
# b is proportional to gammak
b<-solve(Nu)%*%gammak
b/gammak
# b is eigenvector of Nu and M
Nu%*%b/b
M%*%b/b
M%*%gammak/gammak
eigen(M)$vector[,2]/b
# Check eq-diff
Nu%*%b-gammak
#-----------------------------------------------------------------
# See 2. above : Slightly perturbate gammak_generic: almost 2.eigenvector of M
gammak<-gammak_generic<-eigen(M)$vector[,3]
#  gammak_generic[1]<-gammak_generic[1]+1.e-1
k_component<-1
gammak_generic[k_component]<-gammak_generic[k_component]+1.e-3#*rnorm(length(k_component))
rho0<-0.9
# See 2.1 above
# Compute lag-one acf of b for nu>2
grid_size<-10000
# Include negative lambda1: yes/no
with_negative_lambda<-F
# Target gammak_generic is univariate AR(1) as determined above
opt_obj<-find_lambda1_subject_to_holding_time_constraint_func(grid_size,L,gammak_generic,rho0,forecast_horizon,with_negative_lambda)
rho_mat<-opt_obj$rho_mat
nu_vec1<-opt_obj$nu_vec
corb1<-rho_mat[,"rho_yy_best"]
# See 2.2 above
# rho is nearly constant i.e. |nu|>2 can address only a very small portion of all lag-one autocorrelations
# Note also that rho is a monotonous function as shown in paper
ts.plot(cbind(rho_mat[,"rho_yy_best"]),col=c("blue","red","green"),main="lag-one autocorrelation rho(y,y,1)")
# See 2.3 above
# Now we look at |nu|<2rho_max:
# Now all values between -rho_max and +rho_max will be achieved (although grid_anz must be large for convergence)
grid_anz<-grid_size/2
grid_f<-c(-(grid_anz:1),1:grid_anz)
corb2<-NULL
maxrho<-max(eigen(M)$values)
nu_vec2<-NULL
for (i in grid_f)#i<-(-831)
{
# We use (2*i+0.5)/(grid_anz) instead of 2*i/(grid_anz) because integer*maxrho will lead to singular Nu
nu<-(2*i+0.5)/(grid_anz)*maxrho
nu_vec2<-c(nu_vec2,nu)
Nu<-2*M-nu*diag(rep(1,L))
bk_new<-solve(Nu)%*%gammak_generic[1:L]
corb2<-c(corb2,t(bk_new)%*%M%*%bk_new/(t(bk_new)%*%bk_new))
#  if (t(bk_new)%*%M%*%bk_new/(t(bk_new)%*%bk_new)<(-0.3))
#  {
#    print(i)
#    ts.plot(cbind(gammak_generic,bk_new),col=c("red","blue"))
#  }
}
# See 2.3.1 above
# This is a very interesting plot for lag-one autocorrelation rho
#   -rho is no more monotonous
#   -8 very narrow dips (depends on how close gamma_generic is to eigenvector) and one peak
#   --rho_max is achieved at left dip and +rho_max is achieved at right peak
ts.plot(corb2)#ts.plot(cbind(corbh,corb2),col=c("red","blue"))
# If grid_anz is large (for example 10^5) then min/max converge towards min/max eigenvalues of M
max(corb2)
min(corb2)
max(eigen(M)$values)
mat_M<-cbind(corb1,nu_vec1,corb2,nu_vec2)
ts.plot(mat_M[,3])
ts.plot(mat_M[,4])
#-------------------- -------------------
# See 2. above : eigenvector of M but perturbation larger than above
gammak<-gammak_generic<-eigen(M)$vector[,2]
k_component<-1
gammak_generic[k_component]<-gammak_generic[k_component]+1.e-1
rho0<-0.9
# See 2.1 above
# Compute lag-one acf of b for nu>2
#  grid_size<-100000
# Include negative lambda1: yes/no
with_negative_lambda<-F
# Target gammak_generic is univariate AR(1) as determined above
opt_obj<-find_lambda1_subject_to_holding_time_constraint_func(grid_size,L,gammak_generic,rho0,forecast_horizon,with_negative_lambda)
rho_mat<-opt_obj$rho_mat
nu_vec1<-opt_obj$nu_vec
corb1<-rho_mat[,"rho_yy_best"]
ts.plot(corb1)
# See 2.2 above
# rho is nearly constant i.e. |nu|>2 can address only a very small portion of all lag-one autocorrelations
# Note also that rho is a monotonous function as shown in paper
ts.plot(cbind(rho_mat[,"rho_yy_best"]),col=c("blue","red","green"),main="lag-one autocorrelation rho(y,y,1)")
# See 2.3 above
# Now we look at |nu|<2rho_max:
# Now all values between -rho_max and +rho_max will be achieved (although grid_anz must be large for convergence)
grid_anz<-grid_size/2
grid_f<-c(-(grid_anz:1),1:grid_anz)
corb2<-NULL
maxrho<-max(eigen(M)$values)
nu_vec2<-NULL
for (i in grid_f)#i<-(-831)
{
# We use (2*i+0.5)/(grid_anz) instead of 2*i/(grid_anz) because integer*maxrho will lead to singular Nu
nu<-(2*i+0.5)/(grid_anz)*maxrho
nu_vec2<-c(nu_vec2,nu)
Nu<-2*M-nu*diag(rep(1,L))
bk_new<-solve(Nu)%*%gammak_generic[1:L]
corb2<-c(corb2,t(bk_new)%*%M%*%bk_new/(t(bk_new)%*%bk_new))
#  if (t(bk_new)%*%M%*%bk_new/(t(bk_new)%*%bk_new)<(-0.3))
#  {
#    print(i)
#    ts.plot(cbind(gammak_generic,bk_new),col=c("red","blue"))
#  }
}
# See 2.3.1 above
# This is a very interesting plot for lag-one autocorrelation rho
#   -rho is no more monotonous
#   -8 very narrow dips (depends on how close gamma_generic is to eigenvector) and one peak
#   --rho_max is achieved at left dip and +rho_max is achieved at right peak
ts.plot(corb2)
# If grid_anz is large (for example 10^5) then min/max converge towards min/max eigenvalues of M
max(corb2)
min(corb2)
max(eigen(M)$values)
mat_M_l<-cbind(corb1,nu_vec1,corb2,nu_vec2)
ts.plot(mat_M_l[,3])
ts.plot(mat_M_l[,4])
#-------------------------------------------------------------------------------
# See 3 above: Same as 2 but gammak is AR(1)
gammak_generic<-0.6^(1:L)
# See 3.1 above
# Compute lag-one acf of b for nu>2
#  grid_size<-10000
# Include negative lambda1: yes/no
with_negative_lambda<-F
# Target gammak_generic is univariate AR(1) as determined above
opt_obj<-find_lambda1_subject_to_holding_time_constraint_func(grid_size,L,gammak_generic,rho0,forecast_horizon,with_negative_lambda)
rho_mat<-opt_obj$rho_mat
nu_vec1<-opt_obj$nu_vec
corb1<-rho_mat[,"rho_yy_best"]
# rho is monotonous (see proof in paper) and range extends from 0.6 (i.e. target) down to rho_max for |nu|>2 can address only a very small portion of all lag-one autocorrelations
# Note also that rho is a monotonous function as shown in paper
ts.plot(cbind(rho_mat[,"rho_yy_best"]),col=c("blue","red","green"),main="lag-one autocorrelation rho(y,y,1)")
# See 3.2 above
# Now we look at |nu|<2rho_max:
# Now all values between -rho_max and +rho_max will be achieved (although grid_anz must be large for convergence)
grid_anz<-grid_size/2
grid_f<-c(-(grid_anz:1),1:grid_anz)
corb2<-NULL
maxrho<-max(eigen(M)$values)
nu_vec2<-NULL
for (i in grid_f)#i<-(-831)
{
# We use (2*i+0.5)/(grid_anz) instead of 2*i/(grid_anz) because integer*maxrho will lead to singular Nu
nu<-(2*i+0.5)/(grid_anz)*maxrho
nu_vec2<-c(nu_vec2,nu)
Nu<-2*M-nu*diag(rep(1,L))
bk_new<-solve(Nu)%*%gammak_generic[1:L]
corb2<-c(corb2,t(bk_new)%*%M%*%bk_new/(t(bk_new)%*%bk_new))
#  if (t(bk_new)%*%M%*%bk_new/(t(bk_new)%*%bk_new)<(-0.3))
#  {
#    print(i)
#    ts.plot(cbind(gammak_generic,bk_new),col=c("red","blue"))
#  }
}
# This is a very interesting plot for lag-one autocorrelation rho
#   -rho is no more monotonous
#   -trend with damped cycle
#   --rho_max is achieved at left dip and +rho_max is achieved at right peak
ts.plot(corb2)
ts.plot(corb1)
length(corb2)
length(nu_vec2)
# If grid_anz is large (for example 10^5) then min/max converge towards min/max eigenvalues of M
max(corb2)
min(corb2)
max(eigen(M)$values)
mat_ar1<-cbind(corb1,nu_vec1,corb2,nu_vec2)
ts.plot(mat_M[,1])
ts.plot(mat_ar1[,1])
#-------------------------------------------------------------------------------
# See 3 above: Same as 3 but gammak is AR(1) with near unit-root
gammak_generic<-0.99^(1:L)
# See 3.1 above
# Compute lag-one acf of b for nu>2
#  grid_size<-10000
# Include negative lambda1: yes/no
with_negative_lambda<-F
# Target gammak_generic is univariate AR(1) as determined above
opt_obj<-find_lambda1_subject_to_holding_time_constraint_func(grid_size,L,gammak_generic,rho0,forecast_horizon,with_negative_lambda)
rho_mat<-opt_obj$rho_mat
nu_vec1<-opt_obj$nu_vec
corb1<-rho_mat[,"rho_yy_best"]
# rho is monotonous (see proof in paper) and range extends from 0.6 (i.e. target) down to rho_max for |nu|>2 can address only a very small portion of all lag-one autocorrelations
# Note also that rho is a monotonous function as shown in paper
ts.plot(cbind(rho_mat[,"rho_yy_best"]),col=c("blue","red","green"),main="lag-one autocorrelation rho(y,y,1)")
# See 3.2 above
# Now we look at |nu|<2rho_max:
# Now all values between -rho_max and +rho_max will be achieved (although grid_anz must be large for convergence)
grid_anz<-grid_size/2
grid_f<-c(-(grid_anz:1),1:grid_anz)
corb2<-NULL
maxrho<-max(eigen(M)$values)
nu_vec2<-NULL
for (i in grid_f)#i<-(-831)
{
# We use (2*i+0.5)/(grid_anz) instead of 2*i/(grid_anz) because integer*maxrho will lead to singular Nu
nu<-(2*i+0.5)/(grid_anz)*maxrho
nu_vec2<-c(nu_vec2,nu)
Nu<-2*M-nu*diag(rep(1,L))
bk_new<-solve(Nu)%*%gammak_generic[1:L]
corb2<-c(corb2,t(bk_new)%*%M%*%bk_new/(t(bk_new)%*%bk_new))
#  if (t(bk_new)%*%M%*%bk_new/(t(bk_new)%*%bk_new)<(-0.3))
#  {
#    print(i)
#    ts.plot(cbind(gammak_generic,bk_new),col=c("red","blue"))
#  }
}
# This is a very interesting plot for lag-one autocorrelation rho
#   -rho is no more monotonous
#   -trend with damped cycle
#   --rho_max is achieved at left dip and +rho_max is achieved at right peak
ts.plot(corb2)
ts.plot(corb1)
length(corb2)
length(nu_vec2)
# If grid_anz is large (for example 10^5) then min/max converge towards min/max eigenvalues of M
max(corb2)
min(corb2)
max(eigen(M)$values)
mat_ar1_rw<-cbind(corb1,nu_vec1,corb2,nu_vec2)
ts.plot(mat_M[,1])
ts.plot(mat_ar1_rw[,1])
par(mfrow=c(4,2))
anz<-500
#    plot(x=log(log(mat_M[,2])),y=mat_M[,1],xlab="Nu",ylab="rho(1)",main="2. EV: rho(1) for |nu|>2rho_max",ylim=c(min(mat_M[,1])-0.1,1),type="l",col="red")
plot(x=mat_M[,4],y=mat_M[,3],xlab="nu",ylab="rho(1)",main="2. EV small delta:: |nu|<2rho_max",ylim=c(-1,1),type="l",col="blue")
plot(x=mat_M[nrow(mat_M):(nrow(mat_M)-anz),2],y=mat_M[nrow(mat_M):(nrow(mat_M)-anz),1],xlab="nu",ylab="rho(1)",main="2. EV small delta:: |nu|>2rho_max",ylim=c(min(mat_M[nrow(mat_M):(nrow(mat_M)-anz),1])-0.1,1),type="l",col="red")
anz<-2000
plot(x=mat_M_l[,4],y=mat_M_l[,3],xlab="nu",ylab="rho(1)",main="EV larger delta: |nu|<2rho_max",ylim=c(-1,1),type="l",col="blue")
plot(x=(mat_M_l[nrow(mat_M_l)-1:anz,2]),y=mat_M_l[nrow(mat_M_l)-1:anz,1],xlab="nu",ylab="rho(1)",main="2. EV larger delta: |nu|>2rho_max",ylim=c(min(mat_M_l[1:anz,1])-0.1,1),type="l",col="red")
anz<-10000
plot(x=mat_ar1[,4],y=mat_ar1[,3],xlab="nu",ylab="rho(1)",main="AR(1),a1=0.6: |nu|<2rho_max",ylim=c(-1,1),type="l",col="blue")
plot(x=log(mat_ar1[1:anz,2]),y=mat_ar1[1:anz,1],xlab="log(nu)",ylab="rho(1)",main="AR(1),a1=0.6: |nu|>2rho_max",ylim=c(min(mat_ar1[1:anz,1])-0.1,1),type="l",col="red")
plot(x=mat_ar1_rw[,4],y=mat_ar1_rw[,3],xlab="nu",ylab="rho(1)",main="AR(1), a1=0.99: |nu|<2rho_max",ylim=c(-1,1),type="l",col="blue")
plot(x=log(mat_ar1_rw[1:anz,2]),y=mat_ar1_rw[1:anz,1],xlab="log(nu)",ylab="rho(1)",main="AR(1),a1=0.99: |nu|>2rho_max",ylim=c(min(mat_ar1_rw[1:anz,1])-0.1,1),type="l",col="red")
par(mfrow=c(2,2))
anz<-10000
plot(x=mat_ar1[,4],y=mat_ar1[,3],xlab="nu",ylab="rho(1)",main="a1=0.6: |nu|<2rho_max",ylim=c(-1,1),type="l",col="blue")
abline(h=0.15,col="green")
plot(x=log(mat_ar1[1:anz,2]),y=mat_ar1[1:anz,1],xlab="log(nu)",ylab="rho(1)",main="a1=0.6: |nu|>2rho_max",ylim=c(min(mat_ar1[1:anz,1])-0.1,1),type="l",col="red")
plot(x=mat_ar1_rw[,4],y=mat_ar1_rw[,3],xlab="nu",ylab="rho(1)",main="a1=0.99: |nu|<2rho_max",ylim=c(-1,1),type="l",col="blue")
abline(h=0.15,col="green")
plot(x=log(mat_ar1_rw[1:anz,2]),y=mat_ar1_rw[1:anz,1],xlab="log(nu)",ylab="rho(1)",main="a1=0.99: |nu|>2rho_max",ylim=c(min(mat_ar1_rw[1:anz,1])-0.1,1),type="l",col="red")
Sweave(script,output=paste(path.out,"MDFA_Legacy.tex",sep=""))
##############################################################################
opt_b<-function(lambda)
{
nu<-Re(lambda+1/lambda)+0.000001#nu<--2  lambda<-0.5
Nu<-2*M-nu*diag(rep(1,L))
b<-solve(Nu)%*%gammak#ts.plot(b)  eigen(Nu)$values
rho<-t(b)%*%M%*%b/(t(b)%*%b)
crit<-as.double(rho)
return(list(crit=crit,nu=nu))
}
# Solutions when gammak full spectrum \to gammak reduced spectrum i.e. w_i\to 0
len<-L<-10
set.seed(1)
M<-matrix(nrow=L,ncol=L)
M[L,]<-rep(0,L)
M[L-1,]<-c(rep(0,L-1),0.5)
for (i in 1:(L-2))
M[i,]<-c(rep(0,i),0.5,rep(0,L-1-i))
M<-M+t(M)
eigen(M)$values
# 1. Band-limited target
# 1.1 We skip the first/largest eigenvalue for band-limited target
larg<-3
# Epsilon=0 for band-limited target
epsilon<-0.00
w<-c(rep(epsilon,larg),rep(1,L-larg))
w<-w/sqrt(as.double(t(w)%*%w))
gammak<-gammak_bandlimited<-eigen(M)$vector%*%w
ts.plot(gammak_bandlimited)
ts.plot(eigen(M)$vector[,4])
eig<-eigen(M)
smallest_eigen_gammak<-eig$values[L]
largest_eigen_gammak<-eig$values[larg+1]
#---------------
# 1.2 compute lag-one acf of band-limited target
resolution<-1000000
lambda_vec<-pi*(0:resolution)/resolution
crit_vec_bandlimited<-crit_vec<-rep(NA,length(lambda_vec))
for (i in 1:length(lambda_vec))#i<-10000
{
# Unit roots i.e. |nu|<2
lambda<-exp(1.i*lambda_vec[i])
optobj<-opt_b(lambda)
crit_vec_bandlimited[i]<-optobj$crit
}
# 2. Augmented full-bandwith target
# 2.1 Epsilon 10^{-3} leads to very good approximation of band-limited gammak and steep/narrow peaks at singularities, see plot below
epsilon<-0.001
w<-c(rep(epsilon,larg),rep(1,L-larg))
w<-w/sqrt(as.double(t(w)%*%w))
gammak<-gammak_full<-eigen(M)$vector%*%w
ts.plot(gammak_full)
eig<-eigen(M)
smallest_eigen_gammak<-eig$values[L]
largest_eigen_gammak<-eig$values[larg+1]
#---------------
# 2.2 Seek optimal nu for rho1 large
# Select rho1 slightly below largest possible eigenvalue
max(crit_vec_bandlimited)
# This one is slightly below the highest attainable rho of the band-limited design
rho1<-eig$values[larg+1]-0.31
rho1<-eig$values[larg+1]-0.11
# This one is above the highest attainable rho and requires band-extension by point-mass at longer rhos
rho1<-eig$values[larg+1]-0.05
largest_eigen_gammak
# Compare with lag-one acf of (normalized) target
t(gammak_full)%*%M%*%gammak_full
resolution<-1000000
lambda_vec<-pi*(0:resolution)/resolution
nu_vec<-crit_vec_full<-rep(NA,length(lambda_vec))
for (i in 1:length(lambda_vec))#i<-10000
{
# Unit roots i.e. |nu|<2
lambda<-exp(1.i*lambda_vec[i])
optobj<-opt_b(lambda)
crit_vec_full[i]<-optobj$crit
nu_vec[i]<-optobj$nu
}
# 3. Here we search for nu in vicinity of the large singular peaks as well as to the right (down-swing to the right of peak) of the singular peaks:
#   -In each of the possible peaks (on the down-swing) we look at nu (or lambda) such that lag-one acf is closest to ht rho1
#   -We look at the right half of the peaks because they provide minimally flatter (read: better) AR(2)-filter and therefore minimally better criterion value
which_best<-rep(NA,larg+2)
for (i in 1:larg)#i<-2
{
if (F)
{
# Vicinity of i-th singular peak (see plot below): left half and right-halves (less good/optimal)
scan_vec<-i*resolution/(L+1)+((-resolution/(2*(L+1))):(resolution/(2*(L+1))))
}
# Vicinity of i-th singular peak (see plot below): only left half (right-half is ignored): note that this distinction (left/half) is irrelevant asymptotically...
scan_vec<-i*resolution/(L+1)+((-resolution/(2*(L+1))):0)
# Select nu so that 1) holding-time is met and 2) acf is closest to rho1
if (min(abs(crit_vec_full[scan_vec]-rho1))<1/1000)
{
which_best[i]<-scan_vec[which(abs(crit_vec_full[scan_vec]-rho1)==min(abs(crit_vec_full[scan_vec]-rho1)))]
}
}
# Same as above but to the left of the singular peaks: take the two intersections of incompleted with holding-time line
i<-larg+1
scan_vec_l<-(((scan_vec[length(scan_vec)]+1)+resolution/(2*(L+1)))/2):resolution
ret<-abs(crit_vec_full[scan_vec_l]-rho1)
# Second smallest: two intersections
min_ret<-ret[order(ret)][2]
which_best[i:(i+1)]<-scan_vec_l[which(ret<=min_ret)]
# Remove NAs
which_best<-which_best[!is.na(which_best)]
# Plot
plot(x=nu_vec,y=crit_vec_full,main="Lag-one acf as a function of nu",ylab="rho",xlab="nu",type="l",lwd=2)
abline(v=nu_vec[which_best],col="red",lty=3)
abline(h=rho1,col="green",lty=3)
lines(x=nu_vec,y=crit_vec_bandlimited,col="blue",lty=2)
nu_opt_vec<-nu_vec[which_best]
# For each of the above optima: compute b, rho and citerion value
crit_val<-1:length(nu_opt_vec)
b_mat<-NULL
for (i in 1:length(nu_opt_vec))
{
Nu_opt<-2*M-nu_opt_vec[i]*diag(rep(1,L))
b_opt<-solve(Nu_opt)%*%gammak#ts.plot(b)  eigen(Nu)$values
b_opt<-b_opt/as.double(sqrt((t(b_opt)%*%b_opt)))
rho_opt<-t(b_opt)%*%M%*%b_opt
if (t(gammak)%*%b_opt<0)
{
b_opt<--b_opt
}
b_mat<-cbind(b_mat,b_opt)
# Should be nearly vanishing if resolution large
rho1-rho_opt
crit_val[i]<-round(t(gammak)%*%b_opt,3)
# Criterion value: gammak and b_opt are normalized
print(paste("Nu: ",round(nu_opt_vec[i],3),", criterion: ",round(t(gammak)%*%b_opt,3),", rho:", round(rho_opt,3),sep=""))
ts.plot(cbind(gammak,b_opt),col=c("black","blue"))
}
file<-"rho_nu_bandlimited_ex2.pdf"
pdf(file = paste(path.out,file,sep=""), paper = "special", width = 6, height = 6)
par(mfrow=c(1,2))
colo<-c("black","brown","red","violet","orange")
# Plot: selected local optima correspond to red vertical lines
plot(x=nu_vec,y=crit_vec_bandlimited,main="Incomplete",ylab="",xlab="nu",type="l",lwd=2,col="blue",ylim=c(-1,1))
abline(v=nu_vec[which_best[4:(length(which_best))]],col=c(colo[5:length(colo)],"darkgreen"),lty=3,lwd=2)
abline(h=rho1,col="green",lty=2,lwd=2)
abline(h=0.6,col="green",lty=1,lwd=2)
for (i in 4:(length(which_best)))
mtext(at=nu_vec[which_best[i]],crit_val[i],line=-i,side=1,col=c(colo[2:length(colo)],"darkgreen")[i])
# Plot: selected local optima correspond to red vertical lines
plot(x=nu_vec,y=crit_vec_full,main="Completed",ylab="",xlab="nu",type="l",lwd=2)
abline(v=nu_vec[which_best[1:(length(which_best))]],col=c(colo[2:length(colo)],"darkgreen"),lty=3,lwd=2)
abline(h=rho1,col="green",lty=2,lwd=2)
abline(h=0.6,col="green",lty=1,lwd=2)
for (i in 1:(length(which_best)))
mtext(at=nu_vec[which_best[i]],crit_val[i],line=-i,side=1,col=c(colo[2:length(colo)],"darkgreen")[i])
dev.off()
rm(list=ls())
library(xts)
# State-space models (will be replicated by MDFA)
library(dlm)
# Numerical package
library(numDeriv)
# Graphical package for recession-shading (empirical examples based on US-GDP)
library(tis)
#install.packages("devtools")
library(devtools)
# Load MDFA package from github
devtools::install_github("wiaidp/MDFA")
# MDFA package
library(MDFA)
library(mFilter)  # Classic filter designs (be replicated by MDFA)
library(RCurl)    # For getURL() and curl handler / cookie / google login
library(stringr)  # For str_trim() to trip whitespace from strings
library(Quandl)
require (Quandl)
#Quandl.api_key("ivVdJGV57TXA1RX5jgvp")
#  Tucker's libraries
library(expm)
library(R.utils)
library(xtable)
# set directory to GitHub/MDFA-Legacy
#setwd("C:/Users/neide/OneDrive/Documents/GitHub/MDFA-Legacy")
path.main <- paste(getwd(),"/Sweave/",sep="")
path.pgm <- paste(path.main,"Rnw/",sep="")
path.out <- paste(path.main,"Latex/",sep="")
path.data<-paste(path.main,"Data/",sep="")
## Load MDFA R codes #
sourceDirectory(path=paste(path.main,"RcodeTSM/",sep=""), modifiedOnly=FALSE)
## Load SSA R codes (zero-crossings and such)
sourceDirectory(path=paste(path.main,"RcodeSSA/",sep=""), modifiedOnly=FALSE)
script <- paste(path.pgm,"MDFA_Legacy",sep="")
## enforce par(ask=FALSE)
options(device.ask.default=FALSE)
## create a LaTeX file
Sweave(script,output=paste(path.out,"MDFA_Legacy.tex",sep=""))
