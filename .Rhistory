# get MDFA concurrent filter
q <- 20
spec.hat <- mdfa.pergram(x.sim,1)
coint <- phi.matrix - diag(N)
constraints.mdfa <- mdfa.getconstraints(frf.psi,0,NULL,coint,q)
bw.mdfa <- mdfa.filter(frf.psi,spec.hat,constraints.mdfa[[1]],constraints.mdfa[[2]])
x.trend.mdfa <- mvar.filter(x.sim,bw.mdfa[[1]])[(len-q+2):(T.sim-q+1-len),]
x.trend.mdfa <- mvar.filter(x.sim,lp.mdfa[[1]])[(len-q+2):(T.sim-q+1-len),]
lp.mdfa <- mdfa.filter(frf.psi,spec.hat,constraints.mdfa[[1]],constraints.mdfa[[2]])
x.trend.mdfa <- mvar.filter(x.sim,lp.mdfa[[1]])[(len-q+2):(T.sim-q+1-len),]
T.sim <- 5000
N <- 2
phi.matrix <- rbind(c(1/3,2/9),c(2,1/3))
innovar.matrix <- diag(N)
x.init <- rep(0,N)
x.next <- x.init
x.sim <- NULL
for(t in 1:(T.sim+burnin))
{
x.next <- phi.matrix %*% x.next + t(chol(innovar.matrix)) %*% rnorm(N)
x.sim <- cbind(x.sim,x.next)
}
x.sim <- ts(t(x.sim[,-seq(1,burnin)]))
# construct and apply low pass filter
mu <- pi/6
len <- 1000
lp.filter <- c(mu/pi,sin(seq(1,len)*mu)/(pi*seq(1,len)))
lp.filter <- c(rev(lp.filter),lp.filter[-1])
x.trend.ideal <- mvar.filter(x.sim,array(t(lp.filter) %x% diag(N),c(N,N,(2*len+1))))
# frf for ideal low-pass
grid <- T.sim
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
frf.psi <- rep(0,grid)
frf.psi[abs(freq.ft) <= mu] <- 1
frf.psi <- matrix(frf.psi,nrow=1) %x% diag(N)
frf.psi <- array(frf.psi,c(N,N,grid))
# get MDFA concurrent filter
q <- 20
spec.hat <- mdfa.pergram(x.sim,1)
coint <- phi.matrix - diag(N)
constraints.mdfa <- mdfa.getconstraints(frf.psi,0,NULL,coint,q)
lp.mdfa <- mdfa.filter(frf.psi,spec.hat,constraints.mdfa[[1]],constraints.mdfa[[2]])
x.trend.mdfa <- mvar.filter(x.sim,lp.mdfa[[1]])[(len-q+2):(T.sim-q+1-len),]
# compare in-sample performance
print(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)))
# compare to criterion value
diag(lp.mdfa[[2]])
plot.ts(lp.mdfa[[1]][1,1,])
plot.ts(lp.mdfa[[1]][2,2,])
plot.ts(lp.mdfa[[1]][2,1,])
# get MDFA concurrent filter
q <- 30
spec.hat <- mdfa.pergram(x.sim,1)
coint <- phi.matrix - diag(N)
constraints.mdfa <- mdfa.getconstraints(frf.psi,0,NULL,coint,q)
lp.mdfa <- mdfa.filter(frf.psi,spec.hat,constraints.mdfa[[1]],constraints.mdfa[[2]])
x.trend.mdfa <- mvar.filter(x.sim,lp.mdfa[[1]])[(len-q+2):(T.sim-q+1-len),]
# compare in-sample performance
print(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)))
# compare to criterion value
diag(lp.mdfa[[2]])
plot.ts(x.trend.idel[,1])
plot.ts(x.trend.ideal[,1])
lines(x.trend.mdfa[,1],col=2)
psi.sim <- c(2.17150287559847, -8.36795922528, -6.04133725367594,
0.0648981656699, -6.80849700177184, -6.66004335288479,
-0.00016098322952, 0.00051984185863)
psi.sim[7:8] <- c(0,0)
N <- 2
grid <- 1000
delta <- array(t(c(1,-1)) %x% diag(N),c(N,N,2))
mu.sim <- mdfa.wnsim(psi.sim[1:3],rep(1,N),10,Inf)
Sigma.mu <- mu.sim[[2]]
irr.sim <- mdfa.wnsim(psi.sim[4:6],rep(1,N),10,Inf)
Sigma.irr <- irr.sim[[2]]
Sigma.mu
mu.sim <- mdfa.wnsim(rnorm(2),c(1,0),10,Inf)
mu.sim[[1]]
mu.sim[[2]]
eigen(mu.sim[[2]])
mu.sim <- mdfa.wnsim(rnorm(2),c(0,1),10,Inf)
mu.sim <- mdfa.wnsim(rnorm(1),c(0,1),10,Inf)
mu.sim <- mdfa.wnsim(rnorm(2),c(1,0),10,Inf)
mu.sim <- mdfa.wnsim(rnorm(2),c(1,0),10,Inf)
mu.sim <- mdfa.wnsim(rnorm(2),c(1,0),10,Inf)
mu.sim <- mdfa.wnsim(rnorm(3),c(1,1),10,Inf)
mu.sim <- mdfa.wnsim(rnorm(3),c(1,0),10,Inf)
mu.sim <- mdfa.wnsim(rnorm(2),c(1,0),10,Inf)
mu.sim <- mdfa.wnsim(rnorm(3),c(1,0),10,Inf)
ranks <- c(1,0)
psi <- rnorm(2)
N <- length(ranks)
A.mat <- matrix(0,N,N)
A.mat[lower.tri(A.mat)] <- 1
D.dim <- length(ranks[ranks==1])
L.dim <- sum(A.mat[,seq(1,N)[ranks==1],drop=FALSE])
L.psi <- NULL
if(L.dim > 0) L.psi <- psi[1:L.dim]
D.psi <- psi[(L.dim+1):(L.dim+D.dim)]
L.mat <- diag(N)
L.sub <-  L.mat[,seq(1,N)[ranks==1],drop=FALSE]
L.sub[lower.tri(L.mat)[,seq(1,N)[ranks==1]]] <- L.psi
Sigma <- L.sub %*% diag(exp(D.psi)) %*% t(L.sub)
D.psi
D.psi <- psi[(L.dim+1):(L.dim+D.dim),drop=FALSE]
L.mat <- diag(N)
L.sub <-  L.mat[,seq(1,N)[ranks==1],drop=FALSE]
L.sub[lower.tri(L.mat)[,seq(1,N)[ranks==1]]] <- L.psi
Sigma <- L.sub %*% diag(exp(D.psi)) %*% t(L.sub)
L.sub
D.psi
D.psi <- as.vector(psi[(L.dim+1):(L.dim+D.dim)])
Sigma <- L.sub %*% diag(exp(D.psi)) %*% t(L.sub)
diag(D.psi)
D.psi
exp(D.psi)
diag(exp(D.psi))
D.psi <- rnorm(2)
diag(exp(D.psi))
help(diag)
D.psi <- psi[(L.dim+1):(L.dim+D.dim)]
L.mat <- diag(N)
L.sub <-  L.mat[,seq(1,N)[ranks==1],drop=FALSE]
L.sub[lower.tri(L.mat)[,seq(1,N)[ranks==1]]] <- L.psi
Sigma <- L.sub %*% diag(exp(D.psi),nrow=D.dim) %*% t(L.sub)
Sigma
D.dim
mdfa.wnsim <- function(psi,ranks,T,dof)
{
#	generates T x N white noise simulation with student t disturbances
#		of dof degrees of freedom, with covariance matrix determined
#		by parameters psi.
#  ranks is a N-vector of ones and zeroes, gives rank configuration
N <- length(ranks)
A.mat <- matrix(0,N,N)
A.mat[lower.tri(A.mat)] <- 1
D.dim <- length(ranks[ranks==1])
L.dim <- sum(A.mat[,seq(1,N)[ranks==1],drop=FALSE])
L.psi <- NULL
if(L.dim > 0) L.psi <- psi[1:L.dim]
D.psi <- psi[(L.dim+1):(L.dim+D.dim)]
L.mat <- diag(N)
L.sub <-  L.mat[,seq(1,N)[ranks==1],drop=FALSE]
L.sub[lower.tri(L.mat)[,seq(1,N)[ranks==1]]] <- L.psi
Sigma <- L.sub %*% diag(exp(D.psi),nrow=D.dim) %*% t(L.sub)
if(dof == Inf) { eps <- matrix(rnorm(D.dim*T),nrow=D.dim) } else {
eps <- matrix(rt(D.dim*T,df=dof),nrow=D.dim) }
eps <- L.sub %*% diag(exp(D.psi/2)) %*% eps
return(list(t(eps),Sigma))
}
mu.sim <- mdfa.wnsim(psi.sim[1:3],rep(1,N),10,Inf)
mu.sim <- mdfa.wnsim(psi.sim[1:2],c(1,0),10,Inf)
mdfa.wnsim
mdfa.wnsim <- function(psi,ranks,T,dof)
{
#	generates T x N white noise simulation with student t disturbances
#		of dof degrees of freedom, with covariance matrix determined
#		by parameters psi.
#  ranks is a N-vector of ones and zeroes, gives rank configuration
N <- length(ranks)
A.mat <- matrix(0,N,N)
A.mat[lower.tri(A.mat)] <- 1
D.dim <- length(ranks[ranks==1])
L.dim <- sum(A.mat[,seq(1,N)[ranks==1],drop=FALSE])
L.psi <- NULL
if(L.dim > 0) L.psi <- psi[1:L.dim]
D.psi <- psi[(L.dim+1):(L.dim+D.dim)]
L.mat <- diag(N)
L.sub <-  L.mat[,seq(1,N)[ranks==1],drop=FALSE]
L.sub[lower.tri(L.mat)[,seq(1,N)[ranks==1]]] <- L.psi
Sigma <- L.sub %*% diag(exp(D.psi),nrow=D.dim) %*% t(L.sub)
if(dof == Inf) { eps <- matrix(rnorm(D.dim*T),nrow=D.dim) } else {
eps <- matrix(rt(D.dim*T,df=dof),nrow=D.dim) }
eps <- L.sub %*% diag(exp(D.psi/2),nrow=D.dim) %*% eps
return(list(t(eps),Sigma))
}
mu.sim <- mdfa.wnsim(psi.sim[1:3],rep(1,N),10,Inf)
mu.sim <- mdfa.wnsim(psi.sim[1:2],c(1,0),10,Inf)
mu.sim[[1]]
mu.sim[[2]]
exp(psi.sim[1:2])
exp(psi.sim[2])
psi.sim[1]^2*exp(psi.sim[2])
psi.sim[1]*exp(psi.sim[2])
mu.sim[[2]]
mu.sim <- mdfa.wnsim(psi.sim[1:3],rep(1,N),10,Inf)
mu.sim[[2]]
# Simulate a Gaussian co-integrated LLM  of sample size 5000:
set.seed(1234)
T.sim <- 5000
burn <- 1000
N <- 2
psi.sim <- c(2.17150287559847, -8.36795922528,
0.0648981656699, -6.80849700177184, -6.66004335288479,
0,0)
len <- 1000
dpoly <- c(1,-1)
delta <- array(t(dpoly) %x% diag(N),c(N,N,2))
d <- length(dpoly) - 1
mu.sim <- mdfa.wnsim(psi.sim[1:2],c(1,0),T.sim+burn,Inf)
Sigma.mu <- mu.sim[[2]]
mu.sim <- mdfa.ucsim(delta,mu.sim[[1]])[(burn+1-d):(T.sim+burn-d),]
irr.sim <- mdfa.wnsim(psi.sim[4:6],rep(1,N),T.sim,Inf)
Sigma.irr <- irr.sim[[2]]
irr.sim <- irr.sim[[1]]
x.sim <- mu.sim + irr.sim
Sigma.my
Sigma.mu
# construct and apply MB WK and WH filters
grid <- T.sim - d
iden <- array(diag(N),c(N,N,1))
f.mu <- mdfa.spectra(iden,iden,Sigma.mu,grid)
f.irr <- mdfa.spectra(iden,iden,Sigma.irr,grid)
trend.wkfrf <- mdfa.wkfrf(iden,delta,f.irr,f.mu)
Sigma.irr
eigen(Sigma.irr)
dim(f.irr)
grid
f.irr[,,2500]
f.irr[,,1]
delta
delta.noise <- iden
delta.signal <- delta
spec.noise <- f.irr
spec.signal <- f.mu
d.noise <- dim(delta.noise)[3] - 1
d.signal <- dim(delta.signal)[3] - 1
N <- dim(spec.noise)[1]
grid <- dim(spec.noise)[3]
m <- floor(grid/2)
lambda <- 2*pi*(seq(1,grid) - (m+1))/grid
frf.noise <- t(rep(1,grid)) %x% delta.noise[,,1]
if(d.noise > 0) {
for(i in 1:d.noise)
{
frf.noise <- frf.noise + t(exp(-1i*lambda*i)) %x% delta.noise[,,i+1]
} }
frf.noise <- array(frf.noise,c(N,N,grid))
frf.signal <- t(rep(1,grid)) %x% delta.signal[,,1]
if(d.signal > 0) {
for(i in 1:d.signal)
{
frf.signal <- frf.signal + t(exp(-1i*lambda*i)) %x% delta.signal[,,i+1]
} }
frf.signal <- array(frf.signal,c(N,N,grid))
spec.signal.del <- array(t(rep(1,grid) %x% diag(N)),c(N,N,grid))
spec.noise.del <- array(t(rep(1,grid) %x% diag(N)),c(N,N,grid))
spec.data.del <- array(t(rep(1,grid) %x% diag(N)),c(N,N,grid))
frf.wk <- array(t(rep(1,grid) %x% diag(N)),c(N,N,grid))
for(k in 1:grid)
{
spec.noise.del[,,k] <- frf.signal[,,k] %*% spec.noise[,,k] %*% Conj(t(frf.signal[,,k]))
spec.signal.del[,,k] <- frf.noise[,,k] %*% spec.signal[,,k] %*% Conj(t(frf.noise[,,k]))
spec.data.del[,,k] <- spec.noise.del[,,k] + spec.signal.del[,,k]
frf.wk[,,k] <- spec.signal.del[,,k] %*% solve(spec.data.del[,,k])
}
k
spec.signal.del[,,k]
spec.data.del[,,k]
spec.noise.del[,,k]
frf.signal[,,k]
frf.signal[,,1]
Mod(frf.signal[,,1])
Mod(frf.signal[,,100])
sum(Mod(frf.signal[,,100]))
sum(Mod(frf.signal[,,k]))==0
sum(Mod(frf.signal[,,k])) > 0
#' computes the generalized Cholesky decomposition
#'
#' @param Sigma symmetric, non-negative definite matrix
#' @param Rank presumed rank of Sigmma, less than or equal
#'	  		to the dimension of the matrix
#'
#' @return list of length 2 giving L.mat and D.mat.
#'    L.mat: rectangular, lower Cholesky factor
#'		D.mat: vector of diagonal entries in Cholesky decomposition
#' @export
#'
getGCD <- function(Sigma,Rank)
{
##########################################################################
#
#	getGCD
# 	    Copyright (C) 2018  Tucker McElroy
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
############################################################################
################# Documentation #####################################
#
#	Purpose: computes the generalized Cholesky decomposition
#
#	Inputs:
#		Sigma: symmetric, non-negative definite matrix
#		Rank: presumed rank of Sigma, less than or equal
#	  		to the dimension of the matrix
#	Outputs:
#		L.mat: rectangular, lower Cholesky factor
#		D.mat: vector of diagonal entries in Cholesky decomposition
#	Notes: Sigma = L D L', where D is diagonal of dimension equal to
#		the rank, with positive entries, and L is unit lower triangular
#		with number of columns equal to rank
#
#####################################################################
N <- dim(Sigma)[1]
L.mat <- matrix(1,1,1)
L.mat.inv <- L.mat
D.mat <- Re(Sigma[1,1])
if(N > 1) {
for(j in 2:N)
{
D.inv <- 1/D.mat
D.inv[D.mat==0] <- 0
new.sigma <- Sigma[j,1:(j-1)]
if(j==2) { new.sigma <- as.matrix(new.sigma); L.mat <- as.matrix(L.mat) }
new.l <- new.sigma %*% t(Conj(L.mat.inv))*D.inv
new.l.tilde <- new.l %*% L.mat.inv
L.mat <- cbind(L.mat,rep(0,(j-1)))
L.mat <- rbind(L.mat,c(new.l,1))
L.mat.inv <- cbind(L.mat.inv,rep(0,j-1))
L.mat.inv <- rbind(L.mat.inv,c(-1*new.l.tilde,1))
if(j==2) new.d <- Sigma[2,2] - new.l*Conj(new.l)*D.mat
if(j > 2) new.d <- Sigma[j,j] - new.l %*% diag(D.mat) %*% t(Conj(new.l))
new.d <- Re(new.d)
if(new.d <= 0) { new.d <- 0 }
D.mat <- c(D.mat,new.d)
} }
rank.index <- rank(D.mat,ties.method="first")
dims <- seq(1,N)[rank.index > (N-Rank)]
L.mat <- matrix(L.mat[,dims],nrow=N,ncol=length(dims))
D.mat <- D.mat[dims]
return(list(L.mat,D.mat))
}
getGCD(frf.signal[,,k],2)
rank(frf.signal[,,k])
eigen(frf.signal[,,k])
frf.signal[,,k]
getGCD(spec.signal[,,k],2)
eigen(spec.signal[,,k])
qr(spec.signal[,,k])$rank
getGCD(spec.signal[,,k],qr(spec.signal[,,k])$rank)
gcd.out <- getGCD(spec.signal[,,k],qr(spec.signal[,,k])$rank)
gcd.out[[1]] %*% diag(sqrt(gcd.out[[2]]))
help(diag)
gcd.out[[1]] %*% diag(sqrt(gcd.out[[2]]),ncol=1)
spec.rank <- qr(spec.signal[,,k])$rank
gcd.out <- getGCD(spec.signal[,,k],spec.rank)
spec.chol <- gcd.out[[1]] %*% diag(sqrt(gcd.out[[2]]),ncol=spec.rank)
spec.chol
spec.chol %*% t(spec.chol)
spec.noise.inv <- solve(spec.noise[,,k])
t(Conj(spec.chol)) %*% spec.noise.inv %*% spec.chol
temp <- t(Conj(spec.chol)) %*% spec.noise.inv %*% spec.chol
dim(temp)
frf.wk[,,k] <- spec.chol %*% solve( as.matrix(t(Conj(spec.chol)) %*%
spec.noise.inv %*% spec.chol) ) %*% t(Conj(spec.chol)) %*%
spec.noise.inv
frf.wk[,,k]
frf.wk[,,k+1]
k
frf.wk[,,k-1]
frf.wk[,,k+2]
spec.signal.del <- array(t(rep(1,grid) %x% diag(N)),c(N,N,grid))
spec.noise.del <- array(t(rep(1,grid) %x% diag(N)),c(N,N,grid))
spec.data.del <- array(t(rep(1,grid) %x% diag(N)),c(N,N,grid))
frf.wk <- array(t(rep(1,grid) %x% diag(N)),c(N,N,grid))
for(k in 1:grid)
{
spec.noise.del[,,k] <- frf.signal[,,k] %*% spec.noise[,,k] %*% Conj(t(frf.signal[,,k]))
spec.signal.del[,,k] <- frf.noise[,,k] %*% spec.signal[,,k] %*% Conj(t(frf.noise[,,k]))
spec.data.del[,,k] <- spec.noise.del[,,k] + spec.signal.del[,,k]
if( sum(Mod(frf.noise[,,k])) == 0 )
{
frf.wk[,,k] <- 0*diag(N)
}  else
{
if( sum(Mod(frf.signal[,,k])) > 0 )
{
frf.wk[,,k] <- spec.signal.del[,,k] %*% solve(spec.data.del[,,k])
} else
{
spec.rank <- qr(spec.signal[,,k])$rank
gcd.out <- getGCD(spec.signal[,,k],spec.rank)
spec.chol <- gcd.out[[1]] %*% diag(sqrt(gcd.out[[2]]),ncol=spec.rank)
spec.noise.inv <- solve(spec.noise[,,k])
frf.wk[,,k] <- spec.chol %*% solve( as.matrix(t(Conj(spec.chol)) %*%
spec.noise.inv %*% spec.chol) ) %*% t(Conj(spec.chol)) %*%
spec.noise.inv
}
}
}
plot.ts(frf.wk[1,1,])
plot.ts(frf.wk[2,2,])
plot.ts(frf.wk[2,1,])
plot.ts(frf.wk[1,2,])
frf.wk[,,2500]
frf.wk[,,2501]
frf.wk[,,2499]
mdfa.wkfrf <- function(delta.noise,delta.signal,spec.noise,spec.signal)
{
########################################
## mdfa.wkfrf
#   computes model-based  frequency response function
#     for optimal symmetric (WK) signal extraction filter
#   delta.noise: N x N x (d.noise+1) array of noise differencing
#   delta.signal: N x N x (d.signal+1) array of signal differencing
#		spec.noise: array of dimension N x N x grid, consisting of
#     spectrum for differenced noise process at Fourier frequencies
#		spec.signal: array of dimension N x N x grid, consisting of
#     spectrum for differenced signal process at Fourier frequencies
#	Outputs:
#   frf.wk: array of dimension N x N x grid of frf, where
#		  grid is the desired number of frequencies
#  Note: if no delta.noise or delta.signal portions, pass in identity matrices!
#  Conventions: normal polynomial conventions for differencing polynomials
#
# Requires: getGCD  [in MDFA code, this GCD handles complex matrices]
###########################################################################
d.noise <- dim(delta.noise)[3] - 1
d.signal <- dim(delta.signal)[3] - 1
N <- dim(spec.noise)[1]
grid <- dim(spec.noise)[3]
m <- floor(grid/2)
lambda <- 2*pi*(seq(1,grid) - (m+1))/grid
frf.noise <- t(rep(1,grid)) %x% delta.noise[,,1]
if(d.noise > 0) {
for(i in 1:d.noise)
{
frf.noise <- frf.noise + t(exp(-1i*lambda*i)) %x% delta.noise[,,i+1]
} }
frf.noise <- array(frf.noise,c(N,N,grid))
frf.signal <- t(rep(1,grid)) %x% delta.signal[,,1]
if(d.signal > 0) {
for(i in 1:d.signal)
{
frf.signal <- frf.signal + t(exp(-1i*lambda*i)) %x% delta.signal[,,i+1]
} }
frf.signal <- array(frf.signal,c(N,N,grid))
spec.signal.del <- array(t(rep(1,grid) %x% diag(N)),c(N,N,grid))
spec.noise.del <- array(t(rep(1,grid) %x% diag(N)),c(N,N,grid))
spec.data.del <- array(t(rep(1,grid) %x% diag(N)),c(N,N,grid))
frf.wk <- array(t(rep(1,grid) %x% diag(N)),c(N,N,grid))
for(k in 1:grid)
{
spec.noise.del[,,k] <- frf.signal[,,k] %*% spec.noise[,,k] %*% Conj(t(frf.signal[,,k]))
spec.signal.del[,,k] <- frf.noise[,,k] %*% spec.signal[,,k] %*% Conj(t(frf.noise[,,k]))
spec.data.del[,,k] <- spec.noise.del[,,k] + spec.signal.del[,,k]
if( sum(Mod(frf.noise[,,k])) == 0 )
{
frf.wk[,,k] <- 0*diag(N)
}  else
{
if( sum(Mod(frf.signal[,,k])) > 0 )
{
frf.wk[,,k] <- spec.signal.del[,,k] %*% solve(spec.data.del[,,k])
} else
{
spec.rank <- qr(spec.signal[,,k])$rank
gcd.out <- getGCD(spec.signal[,,k],spec.rank)
spec.chol <- gcd.out[[1]] %*% diag(sqrt(gcd.out[[2]]),ncol=spec.rank)
spec.noise.inv <- solve(spec.noise[,,k])
frf.wk[,,k] <- spec.chol %*% solve( as.matrix(t(Conj(spec.chol)) %*%
spec.noise.inv %*% spec.chol) ) %*% t(Conj(spec.chol)) %*%
spec.noise.inv
}
}
}
return(frf.wk)
}
# Simulate a Gaussian co-integrated LLM  of sample size 5000:
set.seed(1234)
T.sim <- 5000
burn <- 1000
N <- 2
psi.sim <- c(2.17150287559847, -8.36795922528,
0.0648981656699, -6.80849700177184, -6.66004335288479,
0,0)
len <- 1000
dpoly <- c(1,-1)
delta <- array(t(dpoly) %x% diag(N),c(N,N,2))
d <- length(dpoly) - 1
mu.sim <- mdfa.wnsim(psi.sim[1:2],c(1,0),T.sim+burn,Inf)
Sigma.mu <- mu.sim[[2]]
mu.sim <- mdfa.ucsim(delta,mu.sim[[1]])[(burn+1-d):(T.sim+burn-d),]
irr.sim <- mdfa.wnsim(psi.sim[4:6],rep(1,N),T.sim,Inf)
Sigma.irr <- irr.sim[[2]]
irr.sim <- irr.sim[[1]]
x.sim <- mu.sim + irr.sim
# construct and apply MB WK and WH filters
grid <- T.sim - d
iden <- array(diag(N),c(N,N,1))
f.mu <- mdfa.spectra(iden,iden,Sigma.mu,grid)
f.irr <- mdfa.spectra(iden,iden,Sigma.irr,grid)
trend.wkfrf <- mdfa.wkfrf(iden,delta,f.irr,f.mu)
trend.wkfilter <- mdfa.coeff(trend.wkfrf,-len,len)
x.trend.ideal <- mvar.filter(x.sim,trend.wkfilter)
trend.whfrf <- mdfa.whfrf(iden,delta,f.irr,f.mu,len)
