fmat <- rbind(fmat,cbind(t(fmat.new),fzero))
} else {
side.mat <- fmat[1:(dim(fmat)[2]-N),(dim(fmat)[2]+1-N):dim(fmat)[2],drop=FALSE]
fmat <- cbind(fmat,rbind(fmat.new,side.mat))
fmat <- rbind(fmat,cbind(t(fmat.new),t(side.mat),fzero))
}
}
}
fpsi <- Re(fpsi)
fmat <- Re(fmat)
opt <- solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat) %*% (t(fpsi) - fmat %*% Q.mat)
opt <- R.mat %*% opt + Q.mat
opt[,1]
opt[,2]
opt.val
t(t(fpsi) - fmat %*% Q.mat) %*%
(solve(fmat) - R.mat %*% solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat)) %*%
(t(fpsi) - fmat %*% Q.mat)
fpsi %*% solve(fmat) %*% t(fpsi)
Re(opt.val) + t(t(fpsi) - fmat %*% Q.mat) %*%
(solve(fmat) - R.mat %*% solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat)) %*%
(t(fpsi) - fmat %*% Q.mat) - fpsi %*% solve(fmat) %*% t(fpsi)
alphaa <- Re(opt.val)
alphaa + t(Q.mat) %*% fmat %*% Q.mat - t(Q.mat) %*% t(fpsi) - fpsi %*% Q.mat
- t(t(fpsi) - fmat %*% Q.mat) %*% R.mat %*% solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat) %*%
(t(fpsi) - fmat %*% Q.mat)
alphaa + t(Q.mat) %*% fmat %*% Q.mat - t(Q.mat) %*% t(fpsi) - fpsi %*% Q.mat
- t(t(fpsi) - fmat %*% Q.mat) %*% R.mat %*% solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat) %*%
(t(fpsi) - fmat %*% Q.mat)
alphaa + t(Q.mat) %*% fmat %*% Q.mat - t(Q.mat) %*% t(fpsi) - fpsi %*% Q.mat
- t(t(fpsi) - fmat %*% Q.mat) %*% R.mat %*% solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat) %*%
(t(fpsi) - fmat %*% Q.mat)
temp <- - t(t(fpsi) - fmat %*% Q.mat) %*% R.mat %*% solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat) %*%
(t(fpsi) - fmat %*% Q.mat)
temp
round(temp,digits=4)
alphaa + t(Q.mat) %*% fmat %*% Q.mat - t(Q.mat) %*% t(fpsi) - fpsi %*% Q.mat
temp2 <- alphaa + t(Q.mat) %*% fmat %*% Q.mat - t(Q.mat) %*% t(fpsi) - fpsi %*% Q.mat
temp2 + temp
alphaa <- Re(opt.val)
alphaa + t(Q.mat) %*% fmat %*% Q.mat - t(Q.mat) %*% t(fpsi) - fpsi %*% Q.mat
t(t(fpsi) - fmat %*% Q.mat) %*% R.mat %*% solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat) %*%
(t(fpsi) - fmat %*% Q.mat)
temp2 <- alphaa + t(Q.mat) %*% fmat %*% Q.mat - t(Q.mat) %*% t(fpsi) - fpsi %*% Q.mat
temp <- - t(t(fpsi) - fmat %*% Q.mat) %*% R.mat %*% solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat) %*%
(t(fpsi) - fmat %*% Q.mat)
temp2 +temp
Re(opt.val) + t(Q.mat) %*% fmat %*% Q.mat - t(Q.mat) %*% t(fpsi) - fpsi %*% Q.mat- t(t(fpsi) - fmat %*% Q.mat) %*% R.mat %*% solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat) %*%
(t(fpsi) - fmat %*% Q.mat)
opt.val <- do.call(cbind,lapply(seq(1,grid),function(i) frf[,,i] %*% spec[,,i] %*% Conj(t(frf[,,i]))))
opt.val <- grid^{-1}*opt.val %*% (rep(1,grid) %x% diag(N))
opt <- solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat) %*% (t(fpsi) - fmat %*% Q.mat)
opt <- R.mat %*% opt + Q.mat
Re(opt.val) + t(Q.mat) %*% fmat %*% Q.mat - t(Q.mat) %*% t(fpsi) - fpsi %*% Q.mat -
t(t(fpsi) - fmat %*% Q.mat) %*% R.mat %*% solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat) %*%
(t(fpsi) - fmat %*% Q.mat)
mdfa.filter <- function(frf,spec,R,Q)
{
#######################################################
#
#	mdfa.filter by Tucker McElroy
#
#	computes optimal concurrent moving average filter
#		as approx of given target filter, using MDFA method,
#		based upon the moving average filter class of length q
#	inputs:
#		frf is array N x N x Grid of complex entries, the target
#			frequency response function Psi(e^{-i lambda})
#			for lambda given by Grid number of Fourier frequencies
#		spec is array N x N x Grid of complex entries, the
#			process/data spectral density matrix f(lambda)
#		R is array N x q x N x M of q-M constraints on the moving
#			average filter solution.
#		Q is array N x q x N of constraints, theta = R phi + Q.
#	outputs:
#		opt.array is array N x N x q of filter coefficients
#		opt.val is N x N matrix corresponding to minimal MSE
#
##############################################################
N <- dim(spec)[1]
grid <- dim(frf)[3]
m <- floor(grid/2)
q <- dim(R)[2]
M <- dim(R)[4]
R.mat <- matrix(R,nrow=N*q,ncol=N*M)
Q.mat <- matrix(Q,ncol=N)
fpsi <- NULL
fmat <- NULL
lambda.ft <- exp(-1i*2*pi*grid^{-1}*(seq(1,grid) - (m+1)))	## this is e^{-i lambda}
opt.val <- do.call(cbind,lapply(seq(1,grid),function(i) frf[,,i] %*% spec[,,i] %*% Conj(t(frf[,,i]))))
opt.val <- grid^{-1}*opt.val %*% (rep(1,grid) %x% diag(N))
for(k in 0:(q-1))
{
fpsi.new <- do.call(cbind,lapply(seq(1,grid),function(i) frf[,,i] %*% spec[,,i]))
fpsi.new <- grid^{-1}*fpsi.new %*% (lambda.ft^{-k} %x% diag(N))
fpsi <- cbind(fpsi,fpsi.new)
fmat.new <- grid^{-1}*matrix(spec,nrow=N) %*% (lambda.ft^{-k} %x% diag(N))
if(k==0) {
fmat <- fmat.new
fzero <- fmat.new
} else {
if(k==1) {
fmat <- cbind(fmat,fmat.new)
fmat <- rbind(fmat,cbind(t(fmat.new),fzero))
} else {
side.mat <- fmat[1:(dim(fmat)[2]-N),(dim(fmat)[2]+1-N):dim(fmat)[2],drop=FALSE]
fmat <- cbind(fmat,rbind(fmat.new,side.mat))
fmat <- rbind(fmat,cbind(t(fmat.new),t(side.mat),fzero))
}
}
}
fpsi <- Re(fpsi)
fmat <- Re(fmat)
opt <- solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat) %*% (t(fpsi) - fmat %*% Q.mat)
opt <- R.mat %*% opt + Q.mat
#	opt.val <- Re(opt.val) + t(t(fpsi) - fmat %*% Q.mat) %*%
#	  (solve(fmat) - R.mat %*% solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat)) %*%
#	  (t(fpsi) - fmat %*% Q.mat) - fpsi %*% solve(fmat) %*% t(fpsi)
Re(opt.val) + t(Q.mat) %*% fmat %*% Q.mat - t(Q.mat) %*% t(fpsi) - fpsi %*% Q.mat -
t(t(fpsi) - fmat %*% Q.mat) %*% R.mat %*% solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat) %*%
(t(fpsi) - fmat %*% Q.mat)
opt.array <- array(t(opt),c(N,N,q))
return(list(opt.array,opt.val))
}
bw.mdfa <- mdfa.filter(trend.wkfrf,spec.hat,constraints.mdfa[[1]],constraints.mdfa[[2]])
x.trend.mdfa <- mvar.filter(x.sim,bw.mdfa[[1]])[(len-q+2):(T.sim-q+1-len),]
# compare in-sample performance
perf_alt <- cbind(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)),
c(mean((x.trend.ideal[,1] - x.trend.conc[,1])^2),
mean((x.trend.ideal[,2] - x.trend.conc[,2])^2)))
colnames(perf_alt) <- c("MDFA","MB")
rownames(perf_alt) <- c("Series 1","Series 2")
# compare to criterion value
print(perf_alt)
diag(bw.mdfa[[2]])
mdfa.filter <- function(frf,spec,R,Q)
{
#######################################################
#
#	mdfa.filter by Tucker McElroy
#
#	computes optimal concurrent moving average filter
#		as approx of given target filter, using MDFA method,
#		based upon the moving average filter class of length q
#	inputs:
#		frf is array N x N x Grid of complex entries, the target
#			frequency response function Psi(e^{-i lambda})
#			for lambda given by Grid number of Fourier frequencies
#		spec is array N x N x Grid of complex entries, the
#			process/data spectral density matrix f(lambda)
#		R is array N x q x N x M of q-M constraints on the moving
#			average filter solution.
#		Q is array N x q x N of constraints, theta = R phi + Q.
#	outputs:
#		opt.array is array N x N x q of filter coefficients
#		opt.val is N x N matrix corresponding to minimal MSE
#
##############################################################
N <- dim(spec)[1]
grid <- dim(frf)[3]
m <- floor(grid/2)
q <- dim(R)[2]
M <- dim(R)[4]
R.mat <- matrix(R,nrow=N*q,ncol=N*M)
Q.mat <- matrix(Q,ncol=N)
fpsi <- NULL
fmat <- NULL
lambda.ft <- exp(-1i*2*pi*grid^{-1}*(seq(1,grid) - (m+1)))	## this is e^{-i lambda}
opt.val <- do.call(cbind,lapply(seq(1,grid),function(i) frf[,,i] %*% spec[,,i] %*% Conj(t(frf[,,i]))))
opt.val <- grid^{-1}*opt.val %*% (rep(1,grid) %x% diag(N))
for(k in 0:(q-1))
{
fpsi.new <- do.call(cbind,lapply(seq(1,grid),function(i) frf[,,i] %*% spec[,,i]))
fpsi.new <- grid^{-1}*fpsi.new %*% (lambda.ft^{-k} %x% diag(N))
fpsi <- cbind(fpsi,fpsi.new)
fmat.new <- grid^{-1}*matrix(spec,nrow=N) %*% (lambda.ft^{-k} %x% diag(N))
if(k==0) {
fmat <- fmat.new
fzero <- fmat.new
} else {
if(k==1) {
fmat <- cbind(fmat,fmat.new)
fmat <- rbind(fmat,cbind(t(fmat.new),fzero))
} else {
side.mat <- fmat[1:(dim(fmat)[2]-N),(dim(fmat)[2]+1-N):dim(fmat)[2],drop=FALSE]
fmat <- cbind(fmat,rbind(fmat.new,side.mat))
fmat <- rbind(fmat,cbind(t(fmat.new),t(side.mat),fzero))
}
}
}
fpsi <- Re(fpsi)
fmat <- Re(fmat)
opt <- solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat) %*% (t(fpsi) - fmat %*% Q.mat)
opt <- R.mat %*% opt + Q.mat
#	opt.val <- Re(opt.val) + t(t(fpsi) - fmat %*% Q.mat) %*%
#	  (solve(fmat) - R.mat %*% solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat)) %*%
#	  (t(fpsi) - fmat %*% Q.mat) - fpsi %*% solve(fmat) %*% t(fpsi)
opt.val <- Re(opt.val) + t(Q.mat) %*% fmat %*% Q.mat - t(Q.mat) %*% t(fpsi) - fpsi %*% Q.mat -
t(t(fpsi) - fmat %*% Q.mat) %*% R.mat %*% solve(t(R.mat) %*% fmat %*% R.mat) %*% t(R.mat) %*%
(t(fpsi) - fmat %*% Q.mat)
opt.array <- array(t(opt),c(N,N,q))
return(list(opt.array,opt.val))
}
bw.mdfa <- mdfa.filter(trend.wkfrf,spec.hat,constraints.mdfa[[1]],constraints.mdfa[[2]])
x.trend.mdfa <- mvar.filter(x.sim,bw.mdfa[[1]])[(len-q+2):(T.sim-q+1-len),]
# compare in-sample performance
perf_alt <- cbind(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)),
c(mean((x.trend.ideal[,1] - x.trend.conc[,1])^2),
mean((x.trend.ideal[,2] - x.trend.conc[,2])^2)))
colnames(perf_alt) <- c("MDFA","MB")
rownames(perf_alt) <- c("Series 1","Series 2")
# compare to criterion value
print(perf_alt)
diag(bw.mdfa[[2]])
T <- dim(ndc)[1]
N <- dim(ndc)[2]
# truncation of ideal filter
trunc <- 8
# construct and apply MB WK and WH filters (from previous exercise)
grid <- T - d
x.trend.ideal <- mvar.filter(ndc,trend.wkfilter[,,(len-trunc*period):(len+trunc*period)])
x.trend.conc <- mvar.filter(ndc,trend.whfilter[,,(len-trunc*period):(len+trunc*period)])
# get MDFA concurrent filter
q <- 30
x.diff <- filter(ndc,dpoly,method="convolution",sides=1)[(d+1):T,]
spec.hat <- mdfa.pergram(x.diff,dpoly)
m <- floor(grid/2)
trend.wkfrf <- mdfa.frf(trend.wkfilter,len,grid)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
constraints.mdfa <- mdfa.getconstraints(trend.wkfrf,c(0,0),NULL,0*diag(N),q)
bw.mdfa <- mdfa.filter(trend.wkfrf,spec.hat,constraints.mdfa[[1]],constraints.mdfa[[2]])
x.trend.mdfa <- mvar.filter(ndc,bw.mdfa[[1]])[(1+trunc*period-q):(T-q-trunc*period),]
# compare in-sample performance
perf_emp <- cbind(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)),
c(mean((x.trend.ideal[,1] - x.trend.conc[,1])^2),
mean((x.trend.ideal[,2] - x.trend.conc[,2])^2)))
colnames(perf_emp) <- c("MDFA","MB")
rownames(perf_emp) <- colnames(ndc)
# compare to criterion value
print(perf_emp)
diag(bw.mdfa[[2]])
# visualize
load("Sweave/Data/starts.RData")
period <- 12
starts <- ts(starts,start=c(1964,1),frequency=period,
names=c("South","West","NE","MW"))
# Simulate a Gaussian atomic seasonal model  of sample size 5000:
set.seed(555)
T.sim <- 5000
burn <- 1000
N <- 4
psi.sim <- c(0.493586093056948, 0.178487258592539, 0.341217399125708,
0.399177274154249, 0.848325304642642, 0.68306879252262,
-2.3494687111314, -5.47534663726587, -6.69385117951384,
-6.08364145983965, 0.875100150810273, 0.221971271148611,
0.500866759201029, 0.340625016984097, 0.791037805495801,
0.985440262768576, -2.52890913740106, -4.29524634814519,
-5.98519527750281, -4.88659954275053, 0.0957466327314851,
0.201313350626488, 0.849351809157598, 0.48420520104336,
0.62643997675928, 1.13945063379914, -4.04217214895869,
-4.68919816059416, -4.73313805629826, -4.0627015759002,
0.923495751608401, -0.396067294450726, 0.244665046194039,
-0.36570474542918, 0.363995718736632, 0.758715172737758,
-3.05567431351817, -4.74337970092605, -4.96364133429136,
-5.06144086942249, 0.262963683605793, -0.181599400661918,
0.149795833258992, -0.105991649100357, 0.21503766242974,
-0.141649861043968, -2.07489346121933, -3.64302004053168,
-5.69277788172285, -5.3689470753418, 1.40718934367933,
-0.0085452878747676, -0.219886337273936, 0.0283662345070971,
1.23786259577472, 0.199834135215749, -4.53336362894347,
-4.70016052568401, -7.07530853221777, -6.03054443735399,
-0.0995506040524902, 0.116607848697947, 0.157899802233636,
-0.0363184981547607, 0.18385749297074, 0.329351477585333,
-2.1377604820296, -3.62882764786239, -5.11279846492415,
-3.62475631527416, 0.124305286145147, 0.0292507920421885,
-0.0873349194845382, 0.178977764316143, 0.484389128732254,
0.265835976421986, 1.87566939226944, 0.1445002084775,
-1.34264222816582, -0.305367634014929, -0.00488431480035087,
-0.000945659564684563, -0.00106126820173145, -0.000413658838890233)
psi.sim[81:84] <- c(0,0,0,0)
len <- 1000
# set up differencing polynomials
dpoly <- c(1,-1,rep(0,10),-1,1)
d <- length(dpoly) - 1
dpoly.0 <- c(1,-2,1)
dpoly.1 <- c(1,-2*cos(pi/6),1)
dpoly.2 <- c(1,-2*cos(2*pi/6),1)
dpoly.3 <- c(1,-2*cos(3*pi/6),1)
dpoly.4 <- c(1,-2*cos(4*pi/6),1)
dpoly.5 <- c(1,-2*cos(5*pi/6),1)
dpoly.6 <- c(1,1)
dpoly.but1 <- polymult(dpoly.2,polymult(dpoly.3,polymult(dpoly.4,polymult(dpoly.5,dpoly.6))))
dpoly.but2 <- polymult(dpoly.1,polymult(dpoly.3,polymult(dpoly.4,polymult(dpoly.5,dpoly.6))))
dpoly.but3 <- polymult(dpoly.1,polymult(dpoly.2,polymult(dpoly.4,polymult(dpoly.5,dpoly.6))))
dpoly.but4 <- polymult(dpoly.1,polymult(dpoly.2,polymult(dpoly.3,polymult(dpoly.5,dpoly.6))))
dpoly.but5 <- polymult(dpoly.1,polymult(dpoly.2,polymult(dpoly.3,polymult(dpoly.4,dpoly.6))))
dpoly.but6 <- polymult(dpoly.1,polymult(dpoly.2,polymult(dpoly.3,polymult(dpoly.4,dpoly.5))))
delta.c <- array(t(dpoly.0) %x% diag(N),c(N,N,3))
delta.but1 <- array(t(dpoly.but1) %x% diag(N),c(N,N,10))
delta.but2 <- array(t(dpoly.but2) %x% diag(N),c(N,N,10))
delta.but3 <- array(t(dpoly.but3) %x% diag(N),c(N,N,10))
delta.but4 <- array(t(dpoly.but4) %x% diag(N),c(N,N,10))
delta.but5 <- array(t(dpoly.but5) %x% diag(N),c(N,N,10))
delta.but6 <- array(t(dpoly.but6) %x% diag(N),c(N,N,11))
delta.seas <- array(t(rep(1,12)) %x% diag(N),c(N,N,12))
# get simulation
mu.sim <- mdfa.wnsim(psi.sim[1:10],rep(1,N),T.sim+burn,Inf)
Sigma.mu <- mu.sim[[2]]
mu.sim <- mdfa.ucsim(array(t(dpoly.0) %x% diag(N),c(N,N,3)),
mu.sim[[1]])[(burn+1-2):(T.sim+burn-2),]
seas1.sim <- mdfa.wnsim(psi.sim[11:20],rep(1,N),T.sim+burn,Inf)
Sigma.seas1 <- seas1.sim[[2]]
seas1.sim <- mdfa.ucsim(array(t(dpoly.1) %x% diag(N),c(N,N,3)),
seas1.sim[[1]])[(burn+1-2):(T.sim+burn-2),]
seas2.sim <- mdfa.wnsim(psi.sim[21:30],rep(1,N),T.sim+burn,Inf)
Sigma.seas2 <- seas2.sim[[2]]
seas2.sim <- mdfa.ucsim(array(t(dpoly.2) %x% diag(N),c(N,N,3)),
seas2.sim[[1]])[(burn+1-2):(T.sim+burn-2),]
seas3.sim <- mdfa.wnsim(psi.sim[31:40],rep(1,N),T.sim+burn,Inf)
Sigma.seas3 <- seas3.sim[[2]]
seas3.sim <- mdfa.ucsim(array(t(dpoly.3) %x% diag(N),c(N,N,3)),
seas3.sim[[1]])[(burn+1-2):(T.sim+burn-2),]
seas4.sim <- mdfa.wnsim(psi.sim[41:50],rep(1,N),T.sim+burn,Inf)
Sigma.seas4 <- seas4.sim[[2]]
seas4.sim <- mdfa.ucsim(array(t(dpoly.4) %x% diag(N),c(N,N,3)),
seas4.sim[[1]])[(burn+1-2):(T.sim+burn-2),]
seas5.sim <- mdfa.wnsim(psi.sim[51:60],rep(1,N),T.sim+burn,Inf)
Sigma.seas5 <- seas5.sim[[2]]
seas5.sim <- mdfa.ucsim(array(t(dpoly.5) %x% diag(N),c(N,N,3)),
seas5.sim[[1]])[(burn+1-2):(T.sim+burn-2),]
seas6.sim <- mdfa.wnsim(psi.sim[61:70],rep(1,N),T.sim+burn,Inf)
Sigma.seas6 <- seas6.sim[[2]]
seas6.sim <- mdfa.ucsim(array(t(dpoly.6) %x% diag(N),c(N,N,2)),
seas6.sim[[1]])[(burn+1-1):(T.sim+burn-1),]
irr.sim <- mdfa.wnsim(psi.sim[71:80],rep(1,N),T.sim,Inf)
Sigma.irr <- irr.sim[[2]]
irr.sim <- irr.sim[[1]]
x.sim <- mu.sim + seas1.sim + seas2.sim + seas3.sim +
seas4.sim + seas5.sim + seas6.sim + irr.sim
# construct and apply MB WK and WH filters
grid <- T.sim - d
iden <- array(diag(N),c(N,N,1))
f.mu <- mdfa.spectra(iden,iden,Sigma.mu,grid)
f.seas1 <- mdfa.spectra(iden,delta.but1,Sigma.seas1,grid)
f.seas2 <- mdfa.spectra(iden,delta.but2,Sigma.seas2,grid)
f.seas3 <- mdfa.spectra(iden,delta.but3,Sigma.seas3,grid)
f.seas4 <- mdfa.spectra(iden,delta.but4,Sigma.seas4,grid)
f.seas5 <- mdfa.spectra(iden,delta.but5,Sigma.seas5,grid)
f.seas6 <- mdfa.spectra(iden,delta.but6,Sigma.seas6,grid)
f.irr <- mdfa.spectra(iden,delta.c,Sigma.irr,grid)
f.signal <- f.mu + f.irr
f.noise <- f.seas1 + f.seas2 + f.seas3 + f.seas4 + f.seas5 + f.seas6
sa.wkfrf <- mdfa.wkfrf(delta.seas,delta.c,f.noise,f.signal)
sa.wkfilter <- mdfa.coeff(sa.wkfrf,-len,len)
x.sa.ideal <- mvar.filter(x.sim,sa.wkfilter)
sa.whfrf <- mdfa.whfrf(delta.seas,delta.c,f.noise,f.signal,len)
sa.whfilter <- mdfa.coeff(sa.whfrf,-len,len)
x.sa.conc <- mvar.filter(x.sim,sa.whfilter)
# get MDFA concurrent filter
q <- 120
x.diff <- filter(x.sim,dpoly,method="convolution",sides=1)[(d+1):T.sim,]
spec.hat <- mdfa.pergram(x.diff,dpoly)
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
constraints.mdfa <- mdfa.getconstraints(sa.wkfrf,c(0,0),seq(1,6)/6,0*diag(N),q)
bw.mdfa <- mdfa.filter(sa.wkfrf,spec.hat,constraints.mdfa[[1]],constraints.mdfa[[2]])
x.sa.mdfa <- mvar.filter(x.sim,bw.mdfa[[1]])[(2+len-q):(T.sim+1-q-len),]
# compare in-sample performance
perf_null <- cbind(c(mean((x.sa.ideal[,1] - x.sa.mdfa[,1])^2),
mean((x.sa.ideal[,2] - x.sa.mdfa[,2])^2),
mean((x.sa.ideal[,3] - x.sa.mdfa[,3])^2),
mean((x.sa.ideal[,4] - x.sa.mdfa[,4])^2)),
c(mean((x.sa.ideal[,1] - x.sa.conc[,1])^2),
mean((x.sa.ideal[,2] - x.sa.conc[,2])^2),
mean((x.sa.ideal[,3] - x.sa.conc[,3])^2),
mean((x.sa.ideal[,4] - x.sa.conc[,4])^2)))
colnames(perf_null) <- c("MDFA","MB")
rownames(perf_null) <- c("Series 1","Series 2","Series 3","Series 4")
# compare to criterion value
print(perf_null)
diag(bw.mdfa[[2]])
# Simulate a Gaussian atomic seasonal model  of sample size 5000:
set.seed(555)
T.sim <- 5000
burn <- 1000
N <- 4
psi.sim <- c(0.493586093056948, 0.178487258592539, 0.341217399125708,
0.399177274154249, 0.848325304642642, 0.68306879252262,
-2.3494687111314, -5.47534663726587, -6.69385117951384,
-6.08364145983965, 0.875100150810273, 0.221971271148611,
0.500866759201029, 0.340625016984097, 0.791037805495801,
0.985440262768576, -2.52890913740106, -4.29524634814519,
-5.98519527750281, -4.88659954275053, 0.0957466327314851,
0.201313350626488, 0.849351809157598, 0.48420520104336,
0.62643997675928, 1.13945063379914, -4.04217214895869,
-4.68919816059416, -4.73313805629826, -4.0627015759002,
0.923495751608401, -0.396067294450726, 0.244665046194039,
-0.36570474542918, 0.363995718736632, 0.758715172737758,
-3.05567431351817, -4.74337970092605, -4.96364133429136,
-5.06144086942249, 0.262963683605793, -0.181599400661918,
0.149795833258992, -0.105991649100357, 0.21503766242974,
-0.141649861043968, -2.07489346121933, -3.64302004053168,
-5.69277788172285, -5.3689470753418, 1.40718934367933,
-0.0085452878747676, -0.219886337273936, 0.0283662345070971,
1.23786259577472, 0.199834135215749, -4.53336362894347,
-4.70016052568401, -7.07530853221777, -6.03054443735399,
-0.0995506040524902, 0.116607848697947, 0.157899802233636,
-0.0363184981547607, 0.18385749297074, 0.329351477585333,
-2.1377604820296, -3.62882764786239, -5.11279846492415,
-3.62475631527416, 0.124305286145147, 0.0292507920421885,
-0.0873349194845382, 0.178977764316143, 0.484389128732254,
0.265835976421986, 1.87566939226944, 0.1445002084775,
-1.34264222816582, -0.305367634014929, -0.00488431480035087,
-0.000945659564684563, -0.00106126820173145, -0.000413658838890233)
psi.sim[81:84] <- c(0,0,0,0)
len <- 1000
# get simulation
mu.sim <- mdfa.wnsim(psi.sim[1:10],rep(1,N),T.sim+burn,Inf)
Sigma.mu <- mu.sim[[2]]
mu.sim <- mdfa.ucsim(array(t(dpoly.0) %x% diag(N),c(N,N,3)),
mu.sim[[1]])[(burn+1-2):(T.sim+burn-2),]
seas1.sim <- mdfa.wnsim(psi.sim[11:20],rep(1,N),T.sim+burn,Inf)
Sigma.seas1 <- seas1.sim[[2]]
seas1.sim <- mdfa.ucsim(array(t(dpoly.1) %x% diag(N),c(N,N,3)),
seas1.sim[[1]])[(burn+1-2):(T.sim+burn-2),]
seas2.sim <- mdfa.wnsim(psi.sim[21:30],rep(1,N),T.sim+burn,Inf)
Sigma.seas2 <- seas2.sim[[2]]
seas2.sim <- mdfa.ucsim(array(t(dpoly.2) %x% diag(N),c(N,N,3)),
seas2.sim[[1]])[(burn+1-2):(T.sim+burn-2),]
seas3.sim <- mdfa.wnsim(psi.sim[31:40],rep(1,N),T.sim+burn,Inf)
Sigma.seas3 <- seas3.sim[[2]]
seas3.sim <- mdfa.ucsim(array(t(dpoly.3) %x% diag(N),c(N,N,3)),
seas3.sim[[1]])[(burn+1-2):(T.sim+burn-2),]
seas4.sim <- mdfa.wnsim(psi.sim[41:50],rep(1,N),T.sim+burn,Inf)
Sigma.seas4 <- seas4.sim[[2]]
seas4.sim <- mdfa.ucsim(array(t(dpoly.4) %x% diag(N),c(N,N,3)),
seas4.sim[[1]])[(burn+1-2):(T.sim+burn-2),]
seas6.sim <- mdfa.wnsim(psi.sim[61:70],rep(1,N),T.sim+burn,Inf)
Sigma.seas6 <- seas6.sim[[2]]
seas6.sim <- mdfa.ucsim(array(t(dpoly.6) %x% diag(N),c(N,N,2)),
seas6.sim[[1]])[(burn+1-1):(T.sim+burn-1),]
irr.sim <- mdfa.wnsim(psi.sim[71:80],rep(1,N),T.sim,Inf)
Sigma.irr <- irr.sim[[2]]
irr.sim <- irr.sim[[1]]
x.sim <- mu.sim + seas1.sim + seas2.sim + seas3.sim +
seas4.sim + seas6.sim + irr.sim
# construct and apply MB WK and WH filters
grid <- T.sim - d
x.sa.ideal <- mvar.filter(x.sim,sa.wkfilter)
x.sa.conc <- mvar.filter(x.sim,sa.whfilter)
# get MDFA concurrent filter
q <- 120
x.diff <- filter(x.sim,dpoly,method="convolution",sides=1)[(d+1):T.sim,]
spec.hat <- mdfa.pergram(x.diff,dpoly)
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
constraints.mdfa <- mdfa.getconstraints(sa.wkfrf,c(0,0),seq(1,6)/6,0*diag(N),q)
bw.mdfa <- mdfa.filter(sa.wkfrf,spec.hat,constraints.mdfa[[1]],constraints.mdfa[[2]])
x.sa.mdfa <- mvar.filter(x.sim,bw.mdfa[[1]])[(2+len-q):(T.sim+1-q-len),]
# compare in-sample performance
perf_alt <- cbind(c(mean((x.sa.ideal[,1] - x.sa.mdfa[,1])^2),
mean((x.sa.ideal[,2] - x.sa.mdfa[,2])^2),
mean((x.sa.ideal[,3] - x.sa.mdfa[,3])^2),
mean((x.sa.ideal[,4] - x.sa.mdfa[,4])^2)),
c(mean((x.sa.ideal[,1] - x.sa.conc[,1])^2),
mean((x.sa.ideal[,2] - x.sa.conc[,2])^2),
mean((x.sa.ideal[,3] - x.sa.conc[,3])^2),
mean((x.sa.ideal[,4] - x.sa.conc[,4])^2)))
colnames(perf_alt) <- c("MDFA","MB")
rownames(perf_alt) <- c("Series 1","Series 2","Series 3","Series 4")
# compare to criterion value
print(perf_alt)
diag(bw.mdfa[[2]])
T <- dim(starts)[1]
N <- dim(starts)[2]
# truncation of ideal filter
trunc <- 10
# construct and apply MB WK and WH filters (from previous exercise)
grid <- T - d
x.sa.ideal <- mvar.filter(starts,sa.wkfilter[,,(len-trunc*period):(len+trunc*period)])
x.sa.conc <- mvar.filter(starts,sa.whfilter[,,(len-trunc*period):(len+trunc*period)])
# get MDFA concurrent filter
q <- 120
x.diff <- filter(starts,dpoly,method="convolution",sides=1)[(d+1):T,]
spec.hat <- mdfa.pergram(x.diff,dpoly)
m <- floor(grid/2)
sa.wkfrf <- mdfa.frf(sa.wkfilter,len,grid)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
constraints.mdfa <- mdfa.getconstraints(sa.wkfrf,c(0,0),seq(1,6)/6,0*diag(N),q)
bw.mdfa <- mdfa.filter(sa.wkfrf,spec.hat,constraints.mdfa[[1]],constraints.mdfa[[2]])
x.sa.mdfa <- mvar.filter(starts,bw.mdfa[[1]])[(1+trunc*period-q):(T-q-trunc*period),]
# compare in-sample performance
perf_emp <- cbind(c(mean((x.sa.ideal[,1] - x.sa.mdfa[,1])^2),
mean((x.sa.ideal[,2] - x.sa.mdfa[,2])^2),
mean((x.sa.ideal[,3] - x.sa.mdfa[,3])^2),
mean((x.sa.ideal[,4] - x.sa.mdfa[,4])^2)),
c(mean((x.sa.ideal[,1] - x.sa.conc[,1])^2),
mean((x.sa.ideal[,2] - x.sa.conc[,2])^2),
mean((x.sa.ideal[,3] - x.sa.conc[,3])^2),
mean((x.sa.ideal[,4] - x.sa.conc[,4])^2)))
colnames(perf_emp) <- c("MDFA","MB")
rownames(perf_emp) <- colnames(starts)
# compare to criterion value
print(perf_emp)
diag(bw.mdfa[[2]])
