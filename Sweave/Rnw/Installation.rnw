

\chapter{Installation of R Packages}

This chapter discusses  the R files needed to run the code given in the text.
 Following these instructions, a reader can replicate the results of this book.

\section{Setting the Paths}

Begin by clearing the workspace: 
<<label=init,echo=TRUE>>=
rm(list=ls())
@
The R code in   various chapters of this book requires installation of the following R packages:
<<label=init,echo=TRUE>>=
# Load packages: time series and xts
library(tseries)
library(xts)
# State-space models (will be replicated by MDFA) 
library(dlm)
# Numerical package 
library(numDeriv)
# Graphical package for recession-shading (empirical examples based on US-GDP)
library(tis) 
#install.packages("devtools")
library(devtools)
# Load MDFA package from github
devtools::install_github("wiaidp/MDFA")
# MDFA package
library(MDFA) 
@
<<label=init,echo=FALSE>>=
# Quandl
# Load required libraries
library(RCurl)    # For getURL() and curl handler / cookie / google login
library(stringr)  # For str_trim() to trip whitespace from strings
library(Quandl)
require (Quandl)
#Quandl.api_key("ivVdJGV57TXA1RX5jgvp")
@
US-GDP data for the empirical examples can be retrieved either directly from 
 Quandl (requiring a preliminary user registration) or from a local data folder,
  which is the default-setting:
<<label=init,echo=TRUE>>=
# Load fresh data from quandl: T/F
#   Default-setting is False: the data will be loaded from local data folder
load_from_quandl <- F
@
Paths to MDFA code, as well as to the US-GDP data, must be provided. 
 It is assumed that the MDFA package is saved to a main folder containing
 subfolders labeled as DFA, MDFA, model-based, and data. 
The R code in the book generates pdf graphs that are saved in a separate folder, 
whose path is specified by {\em path.out}.
<<label=init,echo=TRUE>>=
# Specify disk
disk_id <- "C"
# Set main path
#path.main <- paste(disk_id,":\\wia_desktop\\Projekte\\2016\\MDFA-Legacy\\Sweave\\",sep="")
path.main <- "C:\\Users\\Tucker\\Documents\\MDFAbook\\"
# Set paths to subfolders
  # Path to Latex-folder: all pdfs generated by the R code are filed there
path.out <- paste(path.main,"Latex\\",sep="")
  # Path to data (US-GDP)
path.dat <- paste(path.main,"Data\\",sep="")
  # Path to code that is part of MDFA-Legacy project but not part of MDFA package 
path.pgm <- paste(path.main,"R\\",sep="")
@
The univariate DFA code is the same as in \href{http://blog.zhaw.ch/sef/files/2014/10/DFA.pdf}{DFA}; all 
 empirical examples are and will be fully compatible. 

\section{DFA}\label{dfa_intro}
We here briefly review the relevant facets of \href{http://blog.zhaw.ch/sef/files/2014/10/DFA.pdf}{DFA},
 thereby providing an anchor for the MDFA discussion. 

\subsection{DFT and Periodogram}

The Discrete Fourier Transform (DFT) and the periodogram are defined in Sections 2.2 and 2.3 of
\href{http://blog.zhaw.ch/sef/files/2014/10/DFA.pdf}{DFA}.  
The following periodogram function -- referred to as {\em per} below --
  in the MDFA package replicates these formulae.  Note that frequency $\pi$ is treated differently, depending on
 whether the  sample size is odd or even; also, the value at frequency zero is scaled by $1/\sqrt{2}$,
  which  is explained in later text.  
<<dft,echo=TRUE>>=
head(per,100)
@
This function will be generalized in the new multivariate setting.

\subsection{Basic DFA}

A simple   version of the DFA  based on the MSE criterion alone -- 
 as proposed in Section 4.1 of \href{http://blog.zhaw.ch/sef/files/2014/10/DFA.pdf}{DFA} --
 is included in the MDFA package:  

<<dfa_ms,echo=TRUE>>=
# This function computes MSE DFA solutions 
# L is the length of the MA filter,
# periodogram is the frequency weighting function in the DFA
# Gamma is the transfer function of the symmetric filter (target) and
# Lag is the lag-parameter: Lag=0 implies real-time filtering, Lag=L/2
#     implies symmetric filter
# The function returns optimal coefficients as well as the transfer 
#     function of the optimized real-time filter
head(dfa_ms,100)
@
This function is nested in the multivariate MDFA,
  in the sense that the latter can replicate the former perfectly when suitably parametrized;
 see Section \ref{ex_rep_dfa} below.



\subsection{Customized DFA}

A more general DFA function, called \emph{dfa\textunderscore analytic}, is proposed in Section 4.3.5 of
\href{http://blog.zhaw.ch/sef/files/2014/10/DFA.pdf}{DFA}. Customization and the generic 
 Accuracy-Timeliness-Smoothness (ATS) trilemma are presented in Sections 4.3 and 5 of
 \href{http://blog.zhaw.ch/sef/files/2014/10/DFA.pdf}{DFA}. This function is included in the MDFA package: 
<<dfa_ms,echo=TRUE>>=
head(dfa_analytic)
@
The additional control parameters {\em lambda}, {\em eta} allow for customization of the filter,  as discussed below
 in Chapter \ref{ats_sec}.  The Boolean {\em i1} and {\em i2}
  can enforce useful filter constraints; see Chapter \ref{con_sec}. This function is also encompassed by the   MDFA. 



\section{MDFA}\label{mdfa_intro}

The R code for MDFA is more sophisticated than that of the DFA, and is correspondingly more complex and lengthy. 
 As for the DFA package, the MDFA code can be sourced. We here briefly review the corresponding pieces.


\subsection{Data Matrix}

All time series are collected in a data-\emph{matrix}, say $X$, which is organized as follows: 
\begin{itemize}
\item the first column $X[,1]$ of $X$ always corresponds to the target series: the target series $X[,1]$ is the time series
 to be forecasted, nowcasted or backcasted.
\item Columns $2$, $3$, $\ldots$ of $X$ are allocated to the explanatory variables (more than one in a multivariate setting). 
If the target series is part of the set of explanatory variables (it does not have to be), then it must be assigned a specific column 
-- by convention always the second one -- in $X$, i.e., in this case the target series is entered twice, in the first column (target) and
  in the second column (explanatory data).     
\end{itemize}

\noindent {\bf Example}.  Suppose we study a  two-dimensional signal extraction problem, whereby the target series (first column) 
is part of the set of explanatory variables:
<<dfa_ms,echo=TRUE>>=
set.seed(1)
len <- 100
target <- arima.sim(list(ar=0.9),n=len)
explanatory_2 <- target+rnorm(len)
explanatory <- cbind(target,explanatory_2)
x <- cbind(target,explanatory)
dimnames(x)[[2]] <- c("target","explanatory 1","explanatory 2")
head(x)
@
For a one-step ahead forecast LPP, we might consider lagging both the explanatory variables:
<<dfa_ms,echo=TRUE>>=
x<-cbind(x[,1],lag(x[,2:3],-1))
dimnames(x)[[2]]<-c("target","lagged explanatory 1","lagged explanatory 2")
head(x)
@
 By adopting the frequency-domain methods of this book, we can generalize this construction and
    avoid the introduction of missing values (denoted by NA in R).  $\quad \Box$


\subsection{DFT}

In contrast to the univariate DFA, where the LPP can be expressed in terms of  the periodogram, the multivariate case 
 requires the   DFT of each time series in order to account for cross-sectional dependencies.  These DFTs are complex-valued
 quantities, and the angular portion of the cross-spectrum provides information about the relative phase-shift of each explanatory time series. 
  In the univariate case the relative phase-shift is irrelevant, because the target series and the explanatory series are identical.
 The scope of the method is extended in order to cover the mixed-frequency case, which is discussed in Chapter \ref{mix_sec}. 
 Another facet, is that we allow for the possibility of integrated processes; see Chapter \ref{int_sec}. 
 In order to illustrate some of the new features we briefly look at the main DFT function called {\em spec\textunderscore comp}:
<<dfa_ms,echo=TRUE>>=
spec_comp
@
The inner loop   tracks the columns of the data matrix $X$ and the DFTs are stored in a matrix called \emph{weight\textunderscore func},
  which is returned by the function. The matrix \emph{weight\textunderscore func} collects all DFTs;
  the target series is always in the first column, whereas the DFTs of the explanatory series are in columns $2$, $3$, $\ldots$
 The function \emph{periodogram\textunderscore bp}, called in the above loop, is slightly more general than the DFA 
function \emph{per} proposed in the previous section. In particular, it can handle various integration orders as well as
 seasonal peculiarities. 

\section{Using MDFA}\label{control_dfa}

\subsection{A Versatile User Interface}

MDFA is a generic forecast and signal extraction paradigm. Besides its capacity to  replicate classical time series approaches, 
  MDFA possesses unique features such as customization and regularization (Chapter \ref{reg_sec}); it can
  treat data revisions (Chapter \ref{rev_sec}), mixed-frequency problems (Chapter \ref{mix_sec}),
 and non-stationarity (Chapters \ref{int_sec} and \ref{coint_sec}. Accordingly, the user interface 
is more sophisticated than the precediing DFA package.
Consider the head of the main estimation routine:    

<<dfa_ms,echo=TRUE>>=
head(mdfa_analytic)
@
 Arguments such as  \emph{weight\textunderscore func} (discussed above), the filter length ($L$), and the target specification \emph{Gamma}
 are straightforward.    But there are numerous additional control parameters: the relevance and the modus operandi of these
 will be discussed in this book. 


\subsection{Default Settings}

For convenience, we store a so-called default setting of the parameters in a file called \emph{control\textunderscore default}.
 First we define the data (initialize the DFT matrix) and specify the filter  length:
<<dfa_ms,echo=TRUE>>=
weight_func <- matrix(rep(1:6,2),ncol=2)
L <- 2
@
Given these two entries (DFT and filter length), the default-settings are as follows:
<<dfa_ms,echo=TRUE>>=
K <- nrow(weight_func)-1
lambda <- 0
Lag <- 0
eta <- 0
i1 <- F
i2 <- F
weight_constraint <- rep(1/(ncol(weight_func)-1),ncol(weight_func)-1)
lambda_cross <- lambda_decay <- lambda_smooth <- 0
lin_eta <- F
shift_constraint <- rep(0,ncol(weight_func)-1)
grand_mean <- F
b0_H0 <- NULL
c_eta <- F
weights_only <- F
weight_structure <- c(0,0)
white_noise <- F
synchronicity <- F
lag_mat <- matrix(rep(0:(L-1),ncol(weight_func)-1),nrow=L)
troikaner <- F
@
This particular configuration will be used extensively in Chapter \ref{mse_sec}; it corresponds to the basic MSE criterion 
 (i.e., no customization) without regularization, without design constraints, and without any {\em a priori} knowledge.
  Also, this configuration presumes a   common identical sampling frequency (i.e., no mixed frequency data)
 and the absence of data revisions. The default settings can be obtained by sourcing the corresponding R file:

<<dfa_ms,echo=TRUE>>=
source(file=paste(path.pgm,"control_default.r",sep=""))
@
For later use we   source a convenient plotting function:
<<dfa_ms,echo=TRUE>>=
source(file=paste(path.pgm,"mplot_func.r",sep=""))
@

\subsection{Selected Calls: Classic MSE, Customization and Regularization}

Selected calls of the classic MSE  criterion -- as well as calls utilizing the customization or regularization features --
 are available through dedicated functions in the MDFA package: 
<<dfa_ms,echo=TRUE>>=
head(MDFA_mse)
head(MDFA_mse_constraint)
head(MDFA_cust)
head(MDFA_cust_constraint)
head(MDFA_reg)
head(MDFA_reg_constraint)
@
The heads of the corresponding functions differ in the number of additional arguments available 
when going from specific (MSE) to generic (reg).  The following chapters of the book provide an understanding of
 the use of these functions.
